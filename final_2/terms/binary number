{"batchcomplete":"","query":{"normalized":[{"from":"binary_number","to":"Binary number"}],"pages":{"238686":{"pageid":238686,"ns":0,"title":"Binary number","revisions":[{"contentformat":"text/x-wiki","contentmodel":"wikitext","*":"{{Use dmy dates|date=October 2012}}\n{{Table Numeral Systems}}\nIn [[mathematics]] and [[digital electronics]], a '''binary number''' is a [[number]] expressed in the '''binary numeral system''' or '''base-2 numeral system''' which represents numeric values using two different symbols: typically [[0 (number)|0 (zero)]] and [[1 (number)|1 (one)]]. The [[Radix|base]]-[[2 (number)|2]] system is a [[positional notation]] with a [[radix]] of 2. Because of its straightforward implementation in [[Digital electronics|digital electronic circuitry]] using [[logic gate]]s, the binary system is used internally by almost all modern [[computer|computers and computer-based devices]]. Each digit is referred to as a [[bit]].\n\n==History==\nThe modern binary number system was devised by [[Gottfried Leibniz]] in 1679 and appears in his article ''Explication de l'Arithm\u00e9tique Binaire'' (published in 1703). Systems related to binary numbers have appeared earlier in multiple cultures including ancient Egypt, China, and India. Leibniz was specifically inspired by the Chinese [[I Ching]].\n\n===Egypt===\n{{See also|Ancient Egyptian mathematics}}\n[[File:Oudjat.SVG|thumb|240px|left|Arithmetic values represented by parts of the Eye of Horus]]\nThe scribes of ancient Egypt used two different systems for their fractions, [[Egyptian fraction]]s (not related to the binary number system) and [[Eye of Horus|Horus-Eye]] fractions (so called because many historians of mathematics believe that the symbols used for this system could be arranged to form the eye of [[Horus]], although this has been disputed). Horus-Eye fractions are a binary numbering system for fractional quantities of grain, liquids, or other measures, in which a fraction of a [[hekat]] is expressed as a sum of the binary fractions 1/2, 1/4, 1/8, 1/16, 1/32, and 1/64. Early forms of this system can be found in documents from the [[Fifth Dynasty of Egypt]], approximately 2400 BC, and its fully developed hieroglyphic form dates to the [[Nineteenth Dynasty of Egypt]], approximately 1200 BC.<ref>{{citation|title=Numerical Notation: A Comparative History|first=Stephen|last=Chrisomalis|publisher=Cambridge University Press|year=2010|isbn=9780521878180|pages=42\u201343|url=https://books.google.com/books?id=ux--OWgWvBQC&pg=PA42}}.</ref>\n\nThe method used for [[ancient Egyptian multiplication]] is also closely related to binary numbers. In this method, multiplying one number by a second is performed by a sequence of steps in which a value (initially the first of the two numbers) is either doubled or has the first number added back into it; the order in which these steps are to be performed is given by the binary representation of the second number. This method can be seen in use, for instance, in the [[Rhind Mathematical Papyrus]], which dates to around 1650 BC.<ref>{{citation|title=How Mathematics Happened: The First 50,000 Years|first=Peter Strom|last=Rudman|publisher=Prometheus Books|year=2007|isbn=9781615921768|pages=135\u2013136|url=https://books.google.com/books?id=BtcQq4RUfkUC&pg=PA135}}.</ref>\n\n===China===\n[[File:Bagua-name-earlier.svg|thumb|160px|Daoist Bagua]]\nThe [[I Ching]] dates from the 9th century BC in China.<ref name=\"HackerMoore2002\">{{cite book|author1=Edward Hacker|author2=Steve Moore|author3=Lorraine Patsco|title=I Ching: An Annotated Bibliography|url=https://books.google.com/books?id=S5hLpfFiMCQC&pg=PR13|year=2002|publisher=Routledge|isbn=978-0-415-93969-0|page=13}}</ref> The binary notation in the ''I Ching'' is used to interpret its [[quaternary numeral system|quaternary]]  [[I Ching divination|divination]] technique.{{sfnp|Redmond|Hon|2014|p=227}}\n\nIt is based on taoistic duality of [[yin and yang]].<ref name=\"scientific\">{{cite book|author1=Jonathan Shectman|title=Groundbreaking Scientific Experiments, Inventions, and Discoveries of the 18th Century|url=https://books.google.com/books?id=SsbChdIiflsC&pg=PA29|year=2003|publisher=Greenwood Publishing|isbn=978-0-313-32015-6|page=29}}</ref>\n[[Ba gua|eight trigrams (Bagua)]] and a set of [[Hexagram (I Ching)|64 hexagrams (\"sixty-four\" gua)]], analogous to the three-bit and six-bit binary numerals, were in use at least as early as the [[Zhou Dynasty|Zhou Dynasty of ancient China]].<ref name=\"HackerMoore2002\"/>\n\nThe contemporary scholar [[Shao Yong]] rearranged the hexagrams in a format that resembles modern binary numbers, although he did not intend his arrangement to be used mathematically.{{sfnp|Redmond|Hon|2014|p=227}} Viewing the [[least significant bit]] on top of single hexagrams in [http://www.biroco.com/yijing/sequence.htm Shao Yong's square] and reading along rows either from bottom right to top left with solid lines as 0 and broken lines as 1 or from top left to bottom right with solid lines as 1 and broken lines as 0 hexagrams can be interpreted as sequence from 0 to 63.\n<ref name=\"Shao Yong\u2019s \u201dXiantian Tu\u2018\u2018\">{{cite book|last1=Zhonglian|first1=Shi|last2=Wenzhao|first2=Li|last3=Poser|first3=Hans|title=Leibniz\u2019 Binary System and Shao Yong\u2019s \u201dXiantian Tu\u2018\u2018 in :Das Neueste \u00fcber China: G.W. Leibnizens Novissima Sinica von 1697 : Internationales Symposium, Berlin 4. bis 7. Oktober 1997|date=2000|\npublisher=Franz Steiner Verlag|location=Stuttgart|isbn=3515074481|pages=165\u2013170|url=https://books.google.de/books?id=DkIpP2SsGlIC&pg=PA165|ref=ID3515074481}}</ref>\n\n===India===\nThe Indian scholar [[Pingala]] (c. 2nd century BC) developed a binary system for describing [[prosody (poetry)|prosody]].<ref>{{Cite book|last1=Sanchez|first1=Julio|last2=Canton|first2=Maria P.|title=Microcontroller programming: the microchip PIC|year=2007|publisher=CRC Press|location=Boca Raton, Florida|isbn=0-8493-7189-9|page=37|postscript=<!--None-->}}</ref><ref>W. S. Anglin and J. Lambek, ''The Heritage of Thales'', Springer, 1995, ISBN 0-387-94544-X</ref> He used binary numbers in the form of short and long syllables (the latter equal in length to two short syllables), making it similar to [[Morse code]].<ref>[http://home.ica.net/~roymanju/Binary.htm Binary Numbers in Ancient India]</ref><ref>[http://www.sju.edu/~rhall/Rhythms/Poets/arcadia.pdf Math for Poets and Drummers] (pdf, 145KB)</ref> Pingala's Hindu classic titled [[Chandah-shastra|Chanda\u1e25\u015b\u0101stra]] (8.23) describes the formation of a matrix in order to give a unique value to each meter. The binary representations in Pingala's system increases towards the right, and not to the left like in the binary numbers of the modern, Western [[positional notation]].<ref>{{Cite web|url=http://home.ica.net/~roymanju/Binary.htm|title=Binary Numbers in Ancient India}}</ref><ref>{{Cite book|title=The mathematics of harmony: from Euclid to contemporary mathematics and computer science|first1=Alexey|last1=Stakhov|author1-link=Alexey Stakhov|first2=Scott Anthony|last2=Olsen|isbn=978-981-277-582-5|year=2009|url=https://books.google.com/books?id=K6fac9RxXREC}}</ref>\n\n===Other cultures===\nThe residents of the island of [[Mangareva]] in [[French Polynesia]] were using a hybrid binary-[[decimal]] system before 1450.<ref>{{Cite journal|last=Bender|first=Andrea|last2=Beller|first2=Sieghard|title=Mangarevan invention of binary steps for easier calculation|journal=Proceedings of the National Academy of Sciences|volume=|issue=|date=16 December 2013|doi=10.1073/pnas.1309160110}}</ref> [[Slit drum]]s with binary tones are used to encode messages across Africa and Asia.<ref name=\"scientific\"/>\nSets of binary combinations similar to the I Ching have also been used in traditional African divination systems such as [[If\u00e1]] as well as in [[Middle Ages|medieval]] Western [[geomancy]]. The base-2 system utilized in geomancy had long been widely applied in sub-Saharan Africa.\n\n===Western predecessors to Leibniz===\nIn 1605 [[Francis Bacon]] discussed a system whereby letters of the alphabet could be reduced to sequences of binary digits, which could then be encoded as scarcely visible variations in the font in any random text.<ref name=\"Bacon1605\" /> Importantly for the general theory of binary encoding, he added that this method could be used with any objects at all: \"provided those objects be capable of a twofold difference only; as by Bells, by Trumpets, by Lights and Torches, by the report of Muskets, and any instruments of like nature\".<ref name=\"Bacon1605\">{{Cite web\n|last=Bacon\n|first=Francis\n|authorlink=Francis Bacon\n|title=The Advancement of Learning\n|url=http://home.hiwaay.net/~paul/bacon/advancement/book6ch1.html\n|year=1605\n|volume=6\n|location=London\n|pages=Chapter 1\n|postscript=<!--None-->\n}}\n</ref> (See [[Bacon's cipher]].)\n\n===Leibniz and the I Ching===\n[[File:Gottfried Wilhelm von Leibniz.jpg|thumb|160px|Gottfried Leibniz]]\nThe full title of Leibniz's article is translated into English as the ''\"Explanation of Binary Arithmetic, which uses only the characters 1 and 0, with some remarks on its usefulness, and on the light it throws on the ancient Chinese figures of [[Fu Xi]]\"''.<ref name=lnz>Leibniz G., Explication de l'Arithm\u00e9tique Binaire, Die Mathematische Schriften, ed. C. Gerhardt, Berlin 1879, vol.7, p.223; Engl. transl.[http://www.leibniz-translations.com/binary.htm]</ref> (1703). Leibniz's system uses 0 and 1, like the modern binary numeral system. An example of Leibniz's binary numeral system is as follows:<ref name=lnz/>\n: 0 0 0 1 &nbsp; numerical value 2<sup>0</sup>\n: 0 0 1 0 &nbsp; numerical value 2<sup>1</sup>\n: 0 1 0 0 &nbsp; numerical value 2<sup>2</sup>\n: 1 0 0 0 &nbsp; numerical value 2<sup>3</sup>\nLeibniz interpreted the hexagrams of the I Ching as evidence of binary calculus.<ref name=\"smith\"/>\nAs a [[Sinophile]], Leibniz was aware of the I Ching, noted with fascination how its hexagrams correspond to the binary numbers from 0 to 111111, and concluded that this mapping was evidence of major Chinese accomplishments in the sort of philosophical [[mathematics]] he admired.<ref>{{Cite book\n|last=Aiton\n|first=Eric J.\n|title=Leibniz: A Biography\n|year=1985\n|publisher=Taylor & Francis\n|isbn=0-85274-470-6\n|pages=245\u20138\n|postscript=<!--None-->\n}}</ref>\nLeibniz was first introduced to the ''[[I Ching]]'' through his contact with the French Jesuit [[Joachim Bouvet]], who visited China in 1685 as a missionary. Leibniz saw the ''I Ching'' hexagrams as an affirmation of the [[Universality (philosophy)|universality]] of his own religious beliefs as a Christian.<ref name=\"smith\">{{cite book|author1=J.E.H. Smith|title=Leibniz: What Kind of Rationalist?: What Kind of Rationalist?|url=https://books.google.com/books?id=Da_oP3sJs1oC&pg=PA4153|year=2008|publisher=Springer|isbn=978-1-4020-8668-7|page=415}}</ref> Binary numerals were central to Leibniz's theology. He believed that binary numbers were symbolic of the Christian idea of ''[[ex nihilo|creatio ex nihilo]]'' or creation out of nothing.<ref name=\"lniz\">{{cite book|author1=Yuen-Ting Lai|title=Leibniz, Mysticism and Religion|url=https://books.google.com/books?id=U9dOmVt81UAC&pg=PA149|year=1998|publisher=Springer|isbn=978-0-7923-5223-5|pages=149\u2013150}}</ref>\n\n{{quote|[A concept that] is not easy to impart to the pagans, is the creation ''ex nihilo'' through God's almighty power. Now one can say that nothing in the world can better present and demonstrate this power than the origin of numbers, as it is presented here through the simple and unadorned presentation of One and Zero or Nothing.|Leibniz's letter to the [[Rudolph Augustus, Duke of Brunswick-L\u00fcneburg|Duke of Brunswick]] attached with the ''I Ching'' hexagrams<ref name=\"smith\"/>}}\n\n===Later developments===\n[[File:George Boole color.jpg|thumb|left|160px|George Boole]]\nIn 1854, British mathematician [[George Boole]] published a landmark paper detailing an [[algebra]]ic system of [[logic]] that would become known as [[Boolean algebra (logic)|Boolean algebra]]. His logical calculus was to become instrumental in the design of digital electronic circuitry.<ref>{{cite book |last=Boole |first=George |origyear=1854 |url=http://www.gutenberg.org/etext/15114 |title=An Investigation of the Laws of Thought on Which are Founded the Mathematical Theories of Logic and Probabilities |publisher=Cambridge University Press |edition=Macmillan, Dover Publications, reprinted with corrections [1958] |location=New York |year=2009 |isbn=978-1-108-00153-3}}</ref>\n\nIn 1937, [[Claude Shannon]] produced his master's thesis at [[MIT]] that implemented Boolean algebra and binary arithmetic using electronic relays and switches for the first time in history. Entitled ''[[A Symbolic Analysis of Relay and Switching Circuits]]'', Shannon's thesis essentially founded practical [[digital circuit]] design.<ref>{{cite book |title=A symbolic analysis of relay and switching circuits |last=Shannon |first=Claude Elwood |publisher=Massachusetts Institute of Technology |location=Cambridge |year=1940 |url=http://hdl.handle.net/1721.1/11173}}</ref>\n\nIn November 1937, [[George Stibitz]], then working at [[Bell Labs]], completed a relay-based computer he dubbed the \"Model K\" (for \"'''K'''itchen\", where he had assembled it), which calculated using binary addition.<ref>{{cite web|url=http://www.invent.org/hall_of_fame/140.html |title=National Inventors Hall of Fame \u2013 George R. Stibitz  |date=20 August 2008 |accessdate=5 July 2010}}</ref> Bell Labs authorized a full research program in late 1938 with Stibitz at the helm. Their Complex Number Computer, completed 8 January 1940, was able to  calculate [[complex numbers]]. In a demonstration to the [[American Mathematical Society]] conference at [[Dartmouth College]] on 11 September 1940, Stibitz was able to send the Complex Number Calculator remote commands over telephone lines by a [[teletype]]. It was the first computing machine ever used remotely over a phone line. Some participants of the conference who witnessed the demonstration were [[John von Neumann]], [[John Mauchly]] and [[Norbert Wiener]], who wrote about it in his memoirs.<ref>{{cite web|url=http://stibitz.denison.edu/bio.html |title=George Stibitz : Bio |publisher=Math & Computer Science Department, Denison University |date=30 April 2004 |accessdate=5 July 2010 }}</ref><ref>{{cite web|url=http://www.kerryr.net/pioneers/stibitz.htm |title=Pioneers \u2013 The people and ideas that made a difference \u2013 George Stibitz (1904\u20131995) |publisher=Kerry Redshaw |date=20 February 2006 |accessdate=5 July 2010 }}</ref><ref>{{cite web|url=http://ei.cs.vt.edu/~history/Stibitz.html |title=George Robert Stibitz \u2013 Obituary |publisher=Computer History Association of California |date=6 February 1995 |accessdate=5 July 2010}}</ref>\n\nThe [[Z1 (computer)|Z1 computer]], which was designed and built by [[Konrad Zuse]] between 1935 and 1938, used Boolean logic and binary [[floating point numbers]].<ref name=zuse>{{cite journal |url=http://ed-thelen.org/comp-hist/Zuse_Z1_and_Z3.pdf  |title=Konrad Zuse\u2019s Legacy: The Architecture of the Z1 and Z3 |journal=IEEE Annals of the History of Computing |volume=19 |number=2 |year=1997 |pages=5\u201315 |doi=10.1109/85.586067}}</ref>\n\n==Representation==\nAny number can be represented by any sequence of [[bit]]s (binary digits), which in turn may be represented by any mechanism capable of being in two mutually exclusive states. Any of the following rows of symbols can  be interpreted as the binary numeric value of 667.\n\n{| style=\"text-align:center;\"\n| 1 || 0 || 1 || 0 || 0 || 1 || 1 || 0 || 1 || 1\n|-\n| \u00a6 || \u2212 || \u00a6 || \u2212 || \u2212 || \u00a6 || \u00a6 || \u2212 || \u00a6 || \u00a6\n|-\n| x || o || x || o || o || x || x || o || x || x\n|-\n| y || n || y || n || n || y || y || n || y || y\n|}\n\n[[Image:Binary clock.svg|250px|thumbnail|right|A [[binary clock]] might use [[Light-emitting diode|LEDs]] to express binary values. In this clock, each column of LEDs shows a [[binary-coded decimal]] numeral of the traditional [[sexagesimal]] time.]]\n\nThe numeric value represented in each case is dependent upon the value assigned to each symbol. In a computer, the numeric values may be represented by two different [[voltage]]s; on a [[Magnetic field|magnetic]] [[Disk storage|disk]], magnetic [[Polarity (physics)|polarities]] may be used. A \"positive\", \"[[yes and no|yes]]\", or \"on\" state is not necessarily equivalent to the numerical value of one; it depends on the architecture in use.\n\nIn keeping with customary representation of numerals using [[Arabic numerals]], binary numbers are commonly written using the symbols '''0''' and '''1'''. When written, binary numerals are often subscripted, prefixed or suffixed in order to indicate their base, or radix. The following notations are equivalent:\n\n* 100101 binary (explicit statement of format)\n* 100101b (a suffix indicating binary format; also known as [[Intel convention]]<ref name=\"Kueveler-Schwoch_1996\">{{cite book|title=Arbeitsbuch Informatik - eine praxisorientierte Einf\u00fchrung in die Datenverarbeitung mit Projektaufgabe|language=German|first1=Gerd|last1=K\u00fcveler|first2=Dietrich|last2=Schwoch|date=2013|orig-year=1996|publisher=Vieweg-Verlag, reprint: Springer-Verlag|isbn=978-3-528-04952-2|id=9783322929075|doi=10.1007/978-3-322-92907-5|url=https://books.google.com/books?id=b8-dBgAAQBAJ|accessdate=2015-08-05}}</ref><ref name=\"Kueveler-Schwoch_2007\">{{cite book|title=Informatik f\u00fcr Ingenieure und Naturwissenschaftler: PC- und Mikrocomputertechnik, Rechnernetze|language=German|first1=Gerd|last1=K\u00fcveler|first2=Dietrich|last2=Schwoch|date=2007-10-04|publisher=Vieweg, reprint: Springer-Verlag|edition=5|volume=2|isbn=3834891916|id=9783834891914|url=https://books.google.com/books?id=xQbvPYxceY0C|accessdate=2015-08-05}}</ref>)\n* 100101B (a suffix indicating binary format)\n* bin 100101 (a prefix indicating binary format)\n* 100101<sub>2</sub> (a subscript indicating base-2 (binary) notation)\n* %100101 (a prefix indicating binary format; also known as [[Motorola convention]]<ref name=\"Kueveler-Schwoch_1996\"/><ref name=\"Kueveler-Schwoch_2007\"/>)\n* 0b100101 (a prefix indicating binary format, common in programming languages)\n* 6b100101 (a prefix indicating number of bits in binary format, common in programming languages)\n\nWhen spoken, binary numerals are usually read digit-by-digit, in order to distinguish them from decimal numerals. For example, the binary numeral 100 is pronounced ''one zero zero'', rather than ''one hundred'', to make its binary nature explicit, and for purposes of correctness. Since the binary numeral 100 represents the value four, it would be confusing to refer to the numeral as ''one hundred'' (a word that represents a completely different value, or amount). Alternatively, the binary numeral 100 can be read out as \"four\" (the correct ''value''), but this does not make its binary nature explicit.\n\n==Counting in binary==\n{| class=\"wikitable\" border=\"1\" align=\"right\"\n|-\n! Decimal<BR>pattern\n! Binary<BR>number\n|-\n| 0\n|align=\"right\"| 0\n|-\n| 1\n|align=\"right\"| 1\n|-\n| 2\n|align=\"right\"| 10\n|-\n| 3\n|align=\"right\"| 11\n|-\n| 4\n|align=\"right\"| 100\n|-\n| 5\n|align=\"right\"| 101\n|-\n| 6\n|align=\"right\"| 110\n|-\n| 7\n|align=\"right\"| 111\n|-\n| 8\n|align=\"right\"| 1000\n|-\n| 9\n|align=\"right\"| 1001\n|-\n| 10\n|align=\"right\"| 1010\n|-\n| 11\n|align=\"right\"| 1011\n|-\n| 12 \n|align=\"right\"| 1100\n|-\n| 13\n|align=\"right\"| 1101\n|-\n| 14\n|align=\"right\"| 1110\n|-\n| 15\n|align=\"right\"| 1111\n|}\nCounting in binary is similar to counting in any other number system. Beginning with a single digit, counting proceeds through each symbol, in increasing order. Before examining binary counting, it is useful to briefly discuss the more familiar [[decimal]] counting system as a frame of reference.\n\n===Decimal counting===\n[[Decimal]] counting uses the ten symbols ''0'' through ''9''.  Counting begins with the incremental substitution of the least significant digit (rightmost digit) which is often called the ''first digit''. When the available symbols for this position are exhausted, the least significant digit is reset to ''0'', and the next digit of higher significance (one position to the left) is incremented (''overflow''), and incremental substitution of the low-order digit resumes. This method of reset and overflow is repeated for each digit of significance. Counting progresses as follows:\n\n:000, 001, 002, ... 007, 008, 009, (rightmost digit is reset to zero, and the digit to its left is incremented)\n:0'''1'''0, 011, 012, ...\n:&nbsp;&nbsp;&nbsp;...\n:090, 091, 092, ... 097, 098, 099, (rightmost two digits are reset to zeroes, and next digit is incremented)\n:'''1'''00, 101, 102, ...\n\n===Binary counting===\n[[File:Binary counter.gif|thumb|This counter shows how to count in binary from numbers zero through thirty-one.]]\nBinary counting follows the same procedure, except that only the two symbols ''0'' and ''1'' are available. Thus, after a digit reaches 1 in binary, an increment resets it to 0 but also causes an increment of the next digit to the left:\n\n:0000,\n:000'''1''', (rightmost digit starts over, and next digit is incremented)\n:00'''1'''0, 0011, (rightmost two digits start over, and next digit is incremented)\n:0'''1'''00, 0101, 0110, 0111, (rightmost three digits start over, and the next digit is incremented)\n:'''1'''000, 1001, 1010, 1011, 1100, 1101, 1110, 1111 ...\n\nIn the binary system, each digit represents an increasing power of 2, with the rightmost digit representing 2<sup>0</sup>, the next representing 2<sup>1</sup>, then 2<sup>2</sup>, and so on. The equivalent decimal representation of a binary number is sum of the powers of 2 which each digit represents. For example, the binary number 100101 is converted to decimal form as follows:\n\n:100101<sub>2</sub> = [ ( '''1''' ) \u00d7 2<sup>5</sup> ] + [ ( '''0''' ) \u00d7 2<sup>4</sup> ] + [ ( '''0''' ) \u00d7 2<sup>3</sup> ] + [ ( '''1''' ) \u00d7 2<sup>2</sup> ] + [ ( '''0''' ) \u00d7 2<sup>1</sup> ] + [ ( '''1''' ) \u00d7 2<sup>0</sup> ]\n\n:100101<sub>2</sub> = [ '''1''' \u00d7 32 ] + [ '''0''' \u00d7 16 ] + [ '''0''' \u00d7 8 ] + [ '''1''' \u00d7 4 ] + [ '''0''' \u00d7 2 ] + [ '''1''' \u00d7 1 ]\n\n:'''100101<sub>2</sub> = 37<sub>10</sub>'''\n\n==Fractions==\n\nFractions in binary only terminate if the denominator has [[2 (number)|2]] as the only [[prime factor]]. As a result, 1/10 does not have a finite binary representation, and this causes 10 \u00d7 0.1 not to be precisely equal to 1 in [[floating point arithmetic]]. As an example, to interpret the binary expression for 1/3 = .010101..., this means: 1/3 = 0 \u00d7 '''2<sup>\u22121</sup>''' + 1 \u00d7 '''2<sup>\u22122</sup>''' + 0 \u00d7 '''2<sup>\u22123</sup>''' +  1 \u00d7 '''2<sup>\u22124</sup>''' + ... = 0.3125 + ... An exact value cannot be found with a sum of a finite number of inverse powers of two, the zeros and ones in the binary representation of 1/3 alternate forever.\n\n{| class=\"wikitable\"\n|-\n! Fraction\n! [[Base 10|Decimal]]\n! Binary\n! Fractional approximation\n|-\n| 1/1\n| 1{{pad|0.25em}}or{{pad|0.25em}}0.999...\n| 1{{pad|0.25em}}or{{pad|0.25em}}0.111...\n| 1/2 + 1/4 + 1/8...\n|-\n| 1/2\n| 0.5{{pad|0.25em}}or{{pad|0.25em}}0.4999...\n| 0.1{{pad|0.25em}}or{{pad|0.25em}}0.0111...\n| 1/4 + 1/8 + 1/16 . . .\n|-\n| 1/3\n| 0.333...\n| 0.010101...\n| 1/4 + 1/16 + 1/64 . . .\n|-\n| 1/4\n| 0.25{{pad|0.25em}}or{{pad|0.25em}}0.24999...\n| 0.01{{pad|0.25em}}or{{pad|0.25em}}0.00111...\n| 1/8 + 1/16 + 1/32 . . .\n|-\n| 1/5\n| 0.2{{pad|0.25em}}or{{pad|0.25em}}0.1999...\n| 0.00110011...\n| 1/8 + 1/16 + 1/128 . . .\n|-\n| 1/6\n| 0.1666...\n| 0.0010101...\n| 1/8 + 1/32 + 1/128 . . .\n|-\n| 1/7\n| 0.142857142857...\n| 0.001001...\n| 1/8 + 1/64 + 1/512 . . .\n|-\n| 1/8\n| 0.125{{pad|0.25em}}or{{pad|0.25em}}0.124999...\n| 0.001{{pad|0.25em}}or{{pad|0.25em}}0.000111...\n| 1/16 + 1/32 + 1/64 . . .\n|-\n| 1/9\n| 0.111...\n| 0.000111000111...\n| 1/16 + 1/32 + 1/64 . . .\n|-\n| 1/10\n| 0.1{{pad|0.25em}}or{{pad|0.25em}}0.0999...\n| 0.000110011...\n| 1/16 + 1/32 + 1/256 . . .\n|-\n| 1/11\n| 0.090909...\n| 0.00010111010001011101...\n| 1/16 + 1/64 + 1/128 . . .\n|-\n| 1/12\n| 0.08333...\n| 0.00010101...\n| 1/16 + 1/64 + 1/256 . . .\n|-\n| 1/13\n| 0.076923076923...\n| 0.000100111011000100111011...\n| 1/16 + 1/128 + 1/256 . . .\n|-\n| 1/14\n| 0.0714285714285...\n| 0.0001001001...\n| 1/16 + 1/128 + 1/1024 . . .\n|-\n| 1/15\n| 0.0666...\n| 0.00010001...\n| 1/16 + 1/256 . . .\n|-\n| 1/16\n| 0.0625{{pad|0.25em}}or{{pad|0.25em}}0.0624999...\n| 0.0001{{pad|0.25em}}or{{pad|0.25em}}0.0000111...\n| 1/32 + 1/64 + 1/128 . . .\n|}\n\n==Binary arithmetic==\n[[Arithmetic]] in binary is much like arithmetic in other numeral systems. Addition, subtraction, multiplication, and division can be performed on binary numerals.\n\n===Addition===\n{{main article | binary adder }}\n[[Image:Half Adder.svg|thumbnail|200px|right|The [[circuit diagram]] for a binary [[Adder (electronics)|half adder]], which adds two bits together, producing sum and carry bits.]]\n\nThe simplest arithmetic operation in binary is addition. Adding two single-digit binary numbers is relatively simple, using a form of carrying:\n\n:0 + 0 \u2192 0\n:0 + 1 \u2192 1\n:1 + 0 \u2192 1\n:1 + 1 \u2192 0, carry 1 (since 1 + 1 = 2 = 0 + (1 \u00d7 2<sup>1</sup>)  )\nAdding two \"1\" digits produces a digit \"0\", while 1 will have to be added to the next column. This is similar to what happens in decimal when certain single-digit numbers are added together; if the result equals or exceeds the value of the radix (10), the digit to the left is incremented:\n\n:5 + 5 \u2192 0, carry 1 (since 5 + 5 = 10 = 0 + (1 \u00d7 10<sup>1</sup>)  )\n:7 + 9 \u2192 6, carry 1 (since 7 + 9 = 16 = 6 + (1 \u00d7 10<sup>1</sup>)  )\n\nThis is known as ''carrying''. When the result of an addition exceeds the value of a digit, the procedure is to \"carry\" the excess amount divided by the radix (that is, 10/10) to the left, adding it to the next positional value. This is correct since the next position has a weight that is higher by a factor equal to the radix. Carrying works the same way in binary:\n\n   {{brown|1 1 1 1 1    (carried digits)}}\n     0 1 1 0 1\n +   1 0 1 1 1\n -------------\n = 1 0 0 1 0 0 = 36\n\nIn this example, two numerals are being added together: 01101<sub>2</sub> (13<sub>10</sub>) and 10111<sub>2</sub> (23<sub>10</sub>). The top row shows the carry bits used. Starting in the rightmost column, 1 + 1 = 10<sub>2</sub>. The 1 is carried to the left, and the 0 is written at the bottom of the rightmost column. The second column from the right is added: 1 + 0 + 1 = 10<sub>2</sub> again; the 1 is carried, and 0 is written at the bottom. The third column: 1 + 1 + 1 = 11<sub>2</sub>. This time, a 1 is carried, and a 1 is written in the bottom row. Proceeding like this gives the final answer 100100<sub>2</sub> (36 decimal).\n\nWhen computers must add two numbers, the rule that:\nx [[Exclusive or|xor]] y = (x + y) [[Modulo operation|mod]] 2\nfor any two bits x and y allows for very fast calculation, as well.\n\n==== Long carry method====\nA simplification for many binary addition problems is the [[Long Carry Method]] or [[Brookhouse Method of Binary Addition]].  This method is generally useful in any binary addition where one of the numbers contains a long \"string\" of ones.  It is based on the simple premise that under the binary system, when given a \"string\" of digits composed entirely of {{varserif|n}} ones (''where:'' {{varserif|n}} is any integer length), adding 1 will result in the number 1 followed by a string of {{var|n}} zeros. That concept follows, logically, just as in the decimal system, where adding 1 to a string of {{varserif|n}} 9s will result in the number 1 followed by a string of {{var|n}} 0s:\n\n      Binary                        Decimal\n     1 1 1 1 1     likewise        9 9 9 9 9\n  +          1                  +          1\n   \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014                   \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n   1 0 0 0 0 0                   1 0 0 0 0 0\n\nSuch long strings are quite common in the binary system.  From that one finds that large binary numbers can be added using two simple steps, without excessive carry operations. In the following example, two numerals are being added together: 1 1 1 0 1 1 1 1 1 0<sub>2</sub> (958<sub>10</sub>) and 1 0 1 0 1 1 0 0 1 1<sub>2</sub> (691<sub>10</sub>), using the traditional carry method on the left, and the long carry method on the right:\n\n Traditional Carry Method                       Long Carry Method\n                                 vs.\n   {{brown|1 1 1   1 1 1 1 1      (carried digits)   1 \u2190     1 \u2190}}            carry the 1 until it is one digit past the \"string\" below\n     1 1 1 0 1 1 1 1 1 0                       <s>1 1 1</s> 0 <s>1 1 1 1 1</s> 0  cross out the \"string\",\n +   1 0 1 0 1 1 0 0 1 1                   +   1 0 <s>1</s> 0 1 1 0 0 <s>1</s> 1  and cross out the digit that was added to it\n \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014                    \u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 \n = 1 1 0 0 1 1 1 0 0 0 1                     1 1 0 0 1 1 1 0 0 0 1\n\nThe top row shows the carry bits used. Instead of the standard carry from one column to the next, the lowest-ordered \"1\" with a \"1\" in the corresponding place value beneath it may be added and a \"1\" may be carried to one digit past the end of the series.  The \"used\" numbers must be crossed off, since they are already added. Other long strings may likewise be cancelled using the same technique. Then, simply add together any remaining digits normally. Proceeding in this manner gives the final answer of 1 1 0 0 1 1 1 0 0 0 1<sub>2</sub> (1649<sub>10</sub>).  In our simple example using small numbers, the traditional carry method required eight carry operations, yet the long carry method required only two, representing a substantial reduction of effort.\n\n====Addition table====\n\n{| class=\"wikitable\" style=\"text-align:center\"\n|-\n! style=\"width:1.5em\" |\n! style=\"width:1.5em\" | 0\n! style=\"width:1.5em\" | 1\n! style=\"width:1.5em\" | 10\n! style=\"width:1.5em\" | 11\n! style=\"width:1.5em\" | 100\n|-\n! 0\n| 0\n| 1\n| 10\n| 11\n| 100\n|-\n! 1\n| 1\n| 10\n| 11\n| 100\n| 101\n|-\n! 10\n| 10\n| 11\n| 100\n| 101\n| 110\n|-\n! 11\n| 11\n| 100\n| 101\n| 110\n| 111\n|-\n! 100\n| 100\n| 101\n| 110\n| 111\n| 1000\n|}\n\nThe binary addition table is similar, but not the same, as the [[Logical disjunction#Truth table|truth table]] of the [[logical disjunction]] operation <math>\\or</math>. The difference is that <math>1</math><math>\\or </math><math>1=1</math>, while <math>1+1=10</math>.\n\n=== Subtraction ===\n{{further information|signed number representations|two's complement}}\n\n[[Subtraction]] works in much the same way:\n\n:0 \u2212 0 \u2192 0\n:0 \u2212 1 \u2192 1, borrow 1\n:1 \u2212 0 \u2192 1\n:1 \u2212 1 \u2192 0\nSubtracting a \"1\" digit from a \"0\" digit produces the digit \"1\", while 1 will have to be subtracted from the next column. This is known as ''borrowing''. The principle is the same as for carrying. When the result of a subtraction is less than 0, the least possible value of a digit, the procedure is to \"borrow\" the deficit divided by the radix (that is, 10/10) from the left, subtracting it from the next positional value.\n\n     *   * * *   (starred columns are borrowed from)\n   1 1 0 1 1 1 0\n \u2212     1 0 1 1 1\n ----------------\n = 1 0 1 0 1 1 1\n\n   *             (starred columns are borrowed from)\n   1 0 1 1 1 1 1\n -   1 0 1 0 1 1\n ----------------\n = 0 1 1 0 1 0 0\n\nSubtracting a positive number is equivalent to ''adding'' a [[negative number]] of equal [[absolute value]]. Computers use [[signed number representations]] to handle negative numbers\u2014most commonly the [[two's complement]] notation. Such representations eliminate the need for a separate \"subtract\" operation. Using two's complement notation subtraction can be summarized by the following formula:\n\n'''A \u2212 B = A + not B + 1'''\n\n===Multiplication===<!-- This section is linked from [[Binary-coded decimal]] -->\n[[Multiplication]] in binary is similar to its decimal counterpart. Two numbers {{varserif|A}} and {{varserif|B}} can be multiplied by partial products: for each digit in {{varserif|B}}, the product of that digit in {{varserif|A}} is calculated and written on a new line, shifted leftward so that its rightmost digit lines up with the digit in {{varserif|B}} that was used. The sum of all these partial products gives the final result.\n\nSince there are only two digits in binary, there are only two possible outcomes of each partial multiplication:\n\n* If the digit in {{varserif|B}} is 0, the partial product is also 0\n* If the digit in {{varserif|B}} is 1, the partial product is equal to {{varserif|A}}\n\nFor example, the binary numbers 1011 and 1010 are multiplied as follows:\n\n            1 0 1 1   ({{varserif|A}})\n          \u00d7 1 0 1 0   ({{varserif|B}})\n          ---------\n            0 0 0 0   \u2190 Corresponds to the rightmost 'zero' in {{varserif|B}}\n    +     1 0 1 1     \u2190 Corresponds to the next 'one' in {{varserif|B}}\n    +   0 0 0 0\n    + 1 0 1 1\n    ---------------\n    = 1 1 0 1 1 1 0\n\nBinary numbers can also be multiplied with bits after a [[binary point]]:\n\n                1 0 1 . 1 0 1     {{varserif|A}} (5.625 in decimal)\n              \u00d7 1 1 0 . 0 1       {{varserif|B}} (6.25  in decimal)\n              -------------------\n                    1 . 0 1 1 0 1   \u2190 Corresponds to a 'one' in {{varserif|B}}\n      +           0 0 . 0 0 0 0     \u2190 Corresponds to a 'zero' in {{varserif|B}}\n      +         0 0 0 . 0 0 0\n      +       1 0 1 1 . 0 1\n      +     1 0 1 1 0 . 1\n      ---------------------------\n      =   1 0 0 0 1 1 . 0 0 1 0 1  (35.15625 in decimal)\n\nSee also [[Booth's multiplication algorithm]].\n\n====Multiplication table====\n{| class=\"wikitable\" style=\"text-align:center\"\n|-\n! style=\"width:1.5em\" |\n! style=\"width:1.5em\" | 0\n! style=\"width:1.5em\" | 1\n|-\n! 0\n| 0\n| 0\n|-\n! 1\n| 0\n| 1\n|}\n\nThe binary multiplication table is the same as the [[Logical conjunction#Truth table|truth table]] of the [[logical conjunction]] operation <math>\\and</math>.\n\n===Division===\n:{{See also|Division algorithm}}\n[[Long division]] in binary is again similar to its decimal counterpart.\n\nIn the example below, the [[divisor]] is 101<sub>2</sub>, or 5 decimal, while the [[Division (mathematics)|dividend]] is 11011<sub>2</sub>, or 27 decimal. The procedure is the same as that of decimal [[long division]]; here, the divisor 101<sub>2</sub> goes into the first three digits 110<sub>2</sub> of the dividend one time, so a \"1\" is written on the top line. This result is multiplied by the divisor, and subtracted from the first three digits of the dividend; the next digit (a \"1\") is included to obtain a new three-digit sequence:\n\n               1\n         ___________\n 1 0 1   ) 1 1 0 1 1 \n         \u2212 1 0 1\n           -----\n           0 0 1\n\nThe procedure is then repeated with the new sequence, continuing until the digits in the dividend have been exhausted:\n\n              1 0 1\n        ___________\n 1 0 1  ) 1 1 0 1 1\n        \u2212 1 0 1\n          -----\n              1 1 1\n          \u2212   1 0 1\n              -----\n                1 0\n\nThus, the [[quotient]] of 11011<sub>2</sub> divided by 101<sub>2</sub> is 101<sub>2</sub>, as shown on the top line, while the remainder, shown on the bottom line, is 10<sub>2</sub>. In decimal, 27 divided by 5 is 5, with a remainder of 2.\n\n===Square root ===\nThe process of taking a binary square root digit by digit is the same as for a decimal square root, and is explained [[Methods of computing square roots#Binary numeral system (base 2)|here]]. An example is:\n\n              1 0 0 1\n             ---------\n            \u221a 1010001\n              1\n             ---------\n       101     01  \n                0\n              --------\n       1001     100\n                  0\n              --------\n       10001    10001\n                10001\n               -------\n                    0\n\n==Bitwise operations==\n{{Main article|bitwise operation}}\nThough not directly related to the numerical interpretation of binary symbols, sequences of bits may be manipulated using [[logical connective|Boolean logical operators]]. When a string of binary symbols is manipulated in this way, it is called a [[bitwise operation]]; the logical operators [[Logical conjunction|AND]], [[Logical disjunction|OR]], and [[Exclusive disjunction|XOR]] may be performed on corresponding bits in two binary numerals provided as input. The logical [[Negation|NOT]] operation may be performed on individual bits in a single binary numeral provided as input. Sometimes, such operations may be used as arithmetic short-cuts, and may have other computational benefits as well.  For example, an [[arithmetic shift]] left of a binary number is the equivalent of multiplication by a (positive, integral) power of 2.\n\n==Conversion to and from other numeral systems==\n\n===Decimal===\n[[File:Decimal to Binary Conversion.gif|alt=|frame|Conversion of (357)<sub>10</sub> to binary notation results in (101100101)]]\nTo convert from a base-10 integer to its base-2 (binary) equivalent, the number is [[division by two|divided by two]]. The remainder is the [[least-significant bit]]. The quotient is again divided by two; its remainder becomes the next least significant bit. This process repeats until a quotient of one is reached. The sequence of remainders (including the final quotient of one) forms the binary value, as each remainder must be either zero or one when dividing by two. For example, (357)<sub>10</sub> is expressed as (101100101)<sub>2.</sub><ref>{{Cite web|url=https://www.chalkstreet.com/aptipedia/knowledgebase/base-system/|title=Base System|last=|first=|date=|website=|publisher=|access-date=31 August 2016}}</ref>\n\nConversion from base-2 to base-10 simply inverts the preceding algorithm. The bits of the binary number are used one by one, starting with the most significant (leftmost) bit. Beginning with the value 0, the prior value is doubled, and the next bit is then added to produce the next value. This can be organized in a multi-column table. For example, to convert 10010101101<sub>2</sub> to decimal:\n\n:{| class=\"wikitable\"\n!Prior value\n!\u00d7 2 +\n!Next bit\n!Next value\n|-\n|align=\"right\"|0 ||\u00d7 2 +|| '''1''' || = 1\n|-\n|align=\"right\"|1 ||\u00d7 2 +|| '''0''' || = 2\n|-\n|align=\"right\"|2 ||\u00d7 2 +|| '''0''' || = 4\n|-\n|align=\"right\"|4 ||\u00d7 2 +|| '''1''' || = 9\n|-\n|align=\"right\"|9 ||\u00d7 2 +|| '''0''' || = 18\n|-\n|align=\"right\"|18 ||\u00d7 2 +|| '''1''' || = 37\n|-\n|align=\"right\"|37 ||\u00d7 2 +|| '''0''' || = 74\n|-\n|align=\"right\"|74 ||\u00d7 2 +|| '''1''' || = 149\n|-\n|align=\"right\"|149 ||\u00d7 2 +|| '''1''' || = 299\n|-\n|align=\"right\"|299 ||\u00d7 2 +|| '''0''' || = 598\n|-\n|align=\"right\"|598 ||\u00d7 2 +|| '''1''' || = '''1197'''\n|}\n\nThe result is 1197<sub>10</sub>. Note that the first Prior Value of 0 is simply an initial decimal value. This method is an application of the [[Horner scheme]].\n\n{|\n! Binary&nbsp;\n| 1 || 0 || 0 || 1 || 0 || 1 || 0 || 1 || 1 || 0 || 1 ||\n|-\n! Decimal&nbsp;\n| 1\u00d72<sup>10</sup> + || 0\u00d72<sup>9</sup> + || 0\u00d72<sup>8</sup> + || 1\u00d72<sup>7</sup> + || 0\u00d72<sup>6</sup> + || 1\u00d72<sup>5</sup> + || 0\u00d72<sup>4</sup> + || 1\u00d72<sup>3</sup> + || 1\u00d72<sup>2</sup> + || 0\u00d72<sup>1</sup> + || 1\u00d72<sup>0</sup> = || 1197\n|}\n\nThe fractional parts of a number are converted with similar methods. They are again based on the equivalence of shifting with doubling or halving.\n\nIn a fractional binary number such as 0.11010110101<sub>2</sub>, the first digit is <math>\\begin{matrix} \\frac{1}{2} \\end{matrix}</math>, the second <math>\\begin{matrix} (\\frac{1}{2})^2 = \\frac{1}{4} \\end{matrix}</math>, etc. So if there is a 1 in the first place after the decimal, then the number is at least <math>\\begin{matrix} \\frac{1}{2} \\end{matrix}</math>, and vice versa. Double that number is at least 1. This suggests the algorithm: Repeatedly double the number to be converted, record if the result is at least 1, and then throw away the integer part.\n\nFor example, <math>\\begin{matrix} (\\frac{1}{3}) \\end{matrix}</math><sub>10</sub>, in binary, is:\n\n:{| class=\"wikitable\"\n!Converting!!Result\n|-\n|<math>\\begin{matrix} \\frac{1}{3} \\end{matrix}</math> || 0.\n|-\n|<math>\\begin{matrix} \\frac{1}{3} \\times 2 = \\frac{2}{3} < 1 \\end{matrix}</math> || 0.0\n|-\n|<math>\\begin{matrix} \\frac{2}{3} \\times 2 = 1\\frac{1}{3} \\ge 1 \\end{matrix}</math> || 0.01\n|-\n|<math>\\begin{matrix} \\frac{1}{3} \\times 2 = \\frac{2}{3} < 1 \\end{matrix}</math> || 0.010\n|-\n|<math>\\begin{matrix} \\frac{2}{3} \\times 2 = 1\\frac{1}{3} \\ge 1 \\end{matrix}</math> || 0.0101\n|}\n\nThus the repeating decimal fraction 0.{{overline|3}}... is equivalent to the repeating binary fraction 0.{{overline|01}}... .\n\nOr for example, 0.1<sub>10</sub>, in binary, is:\n\n:{| class=\"wikitable\"\n! Converting                !! Result\n|-\n|          '''0.1'''        || 0.\n|-\n|0.1 \u00d7 2 = '''0.2''' < 1    || 0.0\n|-\n|0.2 \u00d7 2 = '''0.4''' < 1    || 0.00\n|-\n|0.4 \u00d7 2 = '''0.8''' < 1    || 0.000\n|-\n|0.8 \u00d7 2 = '''1.6''' \u2265 1 || 0.0001\n|-\n|0.6 \u00d7 2 = '''1.2''' \u2265 1 || 0.00011\n|-\n|0.2 \u00d7 2 = '''0.4''' < 1    || 0.000110\n|-\n|0.4 \u00d7 2 = '''0.8''' < 1    || 0.0001100\n|-\n|0.8 \u00d7 2 = '''1.6''' \u2265 1 || 0.00011001\n|-\n|0.6 \u00d7 2 = '''1.2''' \u2265 1 || 0.000110011\n|-\n|0.2 \u00d7 2 = '''0.4''' < 1    || 0.0001100110\n|}\n\nThis is also a repeating binary fraction 0.0{{overline|0011}}... .  It may come as a surprise that terminating decimal fractions can have repeating expansions in binary. It is for this reason that many are surprised to discover that 0.1 + ... + 0.1, (10 additions) differs from 1 in [[floating point arithmetic]]. In fact, the only binary fractions with terminating expansions are of the form of an integer divided by a power of 2, which 1/10 is not.\n\nThe final conversion is from binary to decimal fractions. The only difficulty arises with repeating fractions, but otherwise the method is to shift the fraction to an integer, convert it as above, and then divide by the appropriate power of two in the decimal base. For example:\n\n: <math>\n\\begin{align}\nx & = & 1100&.1\\overline{01110}\\ldots \\\\\nx\\times 2^6 & = & 1100101110&.\\overline{01110}\\ldots \\\\\nx\\times 2 & = & 11001&.\\overline{01110}\\ldots \\\\\nx\\times(2^6-2) & = & 1100010101 \\\\\nx & = & 1100010101/111110 \\\\\nx & = & (789/62)_{10}\n\\end{align}\n</math>\n\nAnother way of converting from binary to decimal, often quicker for a person familiar with [[hexadecimal]], is to do so indirectly\u2014first converting (<math>x</math> in binary) into (<math>x</math> in hexadecimal) and then converting (<math>x</math> in hexadecimal) into (<math>x</math> in decimal).\n\nFor very large numbers, these simple methods are inefficient because they perform a large number of multiplications or divisions where one operand is very large. A simple divide-and-conquer algorithm is more effective asymptotically: given a binary number, it is divided by 10<sup>''k''</sup>, where ''k'' is chosen so that the quotient roughly equals the remainder; then each of these pieces is converted to decimal and the two are [[Concatenation|concatenated]]. Given a decimal number, it can be split into two pieces of about the same size, each of which is converted to binary, whereupon the first converted piece is multiplied by 10<sup>''k''</sup> and added to the second converted piece, where ''k'' is the number of decimal digits in the second, least-significant piece before conversion.\n\n===Hexadecimal===\n{{Main article|Hexadecimal}}\n{{Hexadecimal table}}\nBinary may be converted to and from hexadecimal somewhat more easily. This is because the [[radix]] of the hexadecimal system (16) is a power of the radix of the binary system (2). More specifically, 16 = 2<sup>4</sup>, so it takes four digits of binary to represent one digit of hexadecimal, as shown in the adjacent table.\n\nTo convert a hexadecimal number into its binary equivalent, simply substitute the corresponding binary digits:\n\n:3A<sub>16</sub> = 0011 1010<sub>2</sub>\n:E7<sub>16</sub> = 1110 0111<sub>2</sub>\n\nTo convert a binary number into its hexadecimal equivalent, divide it into groups of four bits. If the number of bits isn't a multiple of four, simply insert extra '''0''' bits at the left (called [[Padding (cryptography)#Bit padding|padding]]). For example:\n\n:1010010<sub>2</sub> = 0101 0010 grouped with padding = 52<sub>16</sub>\n:11011101<sub>2</sub> = 1101 1101 grouped = DD<sub>16</sub>\n\nTo convert a hexadecimal number into its decimal equivalent, multiply the decimal equivalent of each hexadecimal digit by the corresponding power of 16 and add the resulting values:\n\n:C0E7<sub>16</sub> = (12 \u00d7 16<sup>3</sup>) + (0 \u00d7 16<sup>2</sup>) + (14 \u00d7 16<sup>1</sup>) + (7 \u00d7 16<sup>0</sup>) = (12 \u00d7 4096) + (0 \u00d7 256) + (14 \u00d7 16) + (7 \u00d7 1) = 49,383<sub>10</sub>\n\n===Octal===\n{{Main article|Octal}}\nBinary is also easily converted to the [[octal]] numeral system, since octal uses a radix of 8, which is a [[power of two]] (namely, 2<sup>3</sup>, so it takes exactly three binary digits to represent an octal digit). The correspondence between octal and binary numerals is the same as for the first eight digits of [[hexadecimal]] in the table above. Binary 000 is equivalent to the octal digit 0, binary 111 is equivalent to octal 7, and so forth.\n\n:{| class=\"wikitable\"  style=\"text-align:center\"\n!Octal!!Binary\n|-\n| 0 || 000\n|-\n| 1 || 001\n|-\n| 2 || 010\n|-\n| 3 || 011\n|-\n| 4 || 100\n|-\n| 5 || 101\n|-\n| 6 || 110\n|-\n| 7 || 111\n|}\n\nConverting from octal to binary proceeds in the same fashion as it does for [[hexadecimal]]:\n\n:65<sub>8</sub> = 110 101<sub>2</sub>\n:17<sub>8</sub> = 001 111<sub>2</sub>\n\nAnd from binary to octal:\n\n:101100<sub>2</sub> = 101 100<sub>2</sub> grouped = 54<sub>8</sub>\n:10011<sub>2</sub> = 010 011<sub>2</sub> grouped with padding = 23<sub>8</sub>\n\nAnd from octal to decimal:\n\n:65<sub>8</sub> = (6 \u00d7 8<sup>1</sup>) + (5 \u00d7 8<sup>0</sup>) = (6 \u00d7 8) + (5 \u00d7 1) = 53<sub>10</sub>\n:127<sub>8</sub> = (1 \u00d7 8<sup>2</sup>) + (2 \u00d7 8<sup>1</sup>) + (7 \u00d7 8<sup>0</sup>) = (1 \u00d7 64) + (2 \u00d7 8) + (7 \u00d7 1) = 87<sub>10</sub>\n\n==Representing real numbers==<!-- This section is linked from [[Chaitin's constant]] -->\nNon-integers can be represented by using negative powers, which are set off from the other digits by means of a [[radix point]] (called a [[decimal point]] in the decimal system). For example, the binary number 11.01<sub>2</sub> thus means:\n\n:{|\n|'''1''' \u00d7 2<sup>1</sup>  || (1 \u00d7 2 = '''2''')           || plus\n|-\n|'''1''' \u00d7 2<sup>0</sup>  || (1 \u00d7 1 = '''1''')           || plus\n|-\n|'''0''' \u00d7 2<sup>\u22121</sup> || (0 \u00d7 {{frac|2}} = '''0''')    || plus\n|-\n|'''1''' \u00d7 2<sup>\u22122</sup> || (1 \u00d7 {{frac|4}} = '''0.25''')\n|}\n\nFor a total of 3.25 decimal.\n\nAll [[dyadic fraction|dyadic rational numbers]] <math>\\frac{p}{2^a}</math> have a ''terminating'' binary numeral\u2014the binary representation has a finite number of terms after the radix point.  Other [[rational numbers]] have binary representation, but instead of terminating, they ''recur'', with a finite sequence of digits repeating indefinitely. For instance\n\n:<math>\\frac{1_{10}}{3_{10}}</math> = <math>\\frac{1_2}{11_2}</math> = 0.01010101{{overline|01}}\u2026<sub>2</sub>\n\n:<math>\\frac{12_{10}}{17_{10}}</math> = <math>\\frac{1100_2}{10001_2}</math> = 0.10110100 10110100 {{overline|10110100}}...<sub>2</sub>\n\nThe phenomenon that the binary representation of any rational is either terminating or recurring also occurs in other radix-based numeral systems.  See, for instance, the explanation in [[decimal]].  Another similarity is the existence of alternative representations for any terminating representation, relying on the fact that 0.111111\u2026 is the sum of the [[geometric series]] 2<sup>\u22121</sup> + 2<sup>\u22122</sup> + 2<sup>\u22123</sup> + ... which is 1.\n\nBinary numerals which neither terminate nor recur represent [[irrational number]]s.  For instance,\n* 0.10100100010000100000100\u2026 does have a pattern, but it is not a fixed-length recurring pattern, so the number is irrational\n* 1.0110101000001001111001100110011111110\u2026 is the binary representation of <math>\\sqrt{2}</math>, the [[square root of 2]], another irrational.  It has no discernible pattern. See [[irrational number]].\n\n== See also ==\n\n{{Portal|Mathematics|Information technology}}\n* [[Binary code]]\n* [[Binary-coded decimal]]\n* [[Finger binary]]\n* [[Gray code]]\n* [[Linear feedback shift register]]\n* [[Offset binary]]\n* [[Quibinary]]\n* [[Reduction of summands]]\n* [[Redundant binary representation]]\n* [[Repeating decimal]]\n* [[SZTAKI Desktop Grid]] searches for generalized binary number systems up to dimension 11.\n* [[Two's complement]]\n\n==Notes==\n{{Reflist|2}}\n\n==References==\n* {{cite book |last1=Sanchez |first1=Julio |last2=Canton |first2=Maria P. |year=2007 |title=Microcontroller programming: the microchip PIC |location=Boca Raton, FL |publisher=CRC Press |page=37 |isbn=0-8493-7189-9}}\n* {{cite book|ref=harv|last1=Redmond|first1=Geoffrey|last2=Hon|first2=Tze-Ki|title=Teaching the I Ching|date=2014|publisher=Oxford University Press|isbn=0-19-976681-9}}\n\n==External links==\n<!--=========================================================\n\n  There are MANY web pages devoted to binary numbers. This section should not be a repository of such web pages.\n  Before adding another external link here, make sure it provides a unique resource beyond what is already here.\n  We do not need yet another explanation of the binary number system.\n\n======\n======\n======\n======\n========\n-->\n{{Commons category|Binary numeral system}}\n* [http://www.cut-the-knot.org/do_you_know/BinaryHistory.shtml Binary System] at [[cut-the-knot]]\n* [http://www.cut-the-knot.org/blue/frac_conv.shtml Conversion of Fractions] at [[cut-the-knot]]\n* [http://www.mathsisfun.com/binary-digits.html Binary Digits] at [http://www.mathsisfun.com/ Math Is Fun]\n* [http://www.wikihow.com/Convert-from-Decimal-to-Binary How to Convert from Decimal to Binary] at [[wikiHow]]\n* [http://www.circuitdesign.info/blog/2008/06/the-binary-number-system-part-2-binary-weighting/ Learning exercise for children at CircuitDesign.info]\n* [http://gwydir.demon.co.uk/jo/numbers/binary/kids.htm Binary Counter with Kids]\n* [http://gwydir.demon.co.uk/jo/numbers/binary/cards.htm \"Magic\" Card Trick]\n* [http://www.mycomputeraid.com/networking-support/general-networking-support/howto-read-binary-basics/ Quick reference on Howto read binary]\n* [http://calc.50x.eu/ Binary converter to HEX/DEC/OCT with direct access to bits]\n* [http://www.baconlinks.com/docs/BILITERAL.doc Sir Francis Bacon's BiLiteral Cypher system], predates binary number system.\n* Leibniz' binary numeral system, 'De progressione dyadica', 1679, online and analyzed on ''[https://www.bibnum.education.fr/calculinformatique/calcul/de-la-numeration-binaire BibNum]'' <small>[click '\u00e0 t\u00e9l\u00e9charger' for English analysis]</small>\n\n{{Authority control}}\n\n[[Category:Binary arithmetic]]\n[[Category:Computer arithmetic]]\n[[Category:Elementary arithmetic]]\n[[Category:Positional numeral systems]]\n[[Category:Gottfried Leibniz]]"}]}}}}