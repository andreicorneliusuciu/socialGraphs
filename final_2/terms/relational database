{"batchcomplete":"","query":{"normalized":[{"from":"relational_database","to":"Relational database"}],"pages":{"25873":{"pageid":25873,"ns":0,"title":"Relational database","revisions":[{"contentformat":"text/x-wiki","contentmodel":"wikitext","*":"{{Refimprove|date=November 2014}}\n\nA '''relational database''' is a digital [[database]] whose organization is based on the [[relational model]] of data, as proposed by [[E. F. Codd]] in 1970.<ref name=codd/>\nThe various software systems used to maintain relational databases are known as a [[relational database management system]] (RDBMS).\nVirtually all relational database systems use [[SQL]] (Structured Query Language) as the language for querying and maintaining the database.\n\n==Relational model==\n{{main|Relational model}}\nThis model organizes data into one or more [[table (database)|tables]] (or \"relations\") of [[Column (database)|columns]] and [[row (database)|rows]], with a unique key identifying each row. Rows are also called [[Record (computer science)|records]] or [[tuple]]s.<ref>{{cite web|url=https://docs.oracle.com/javase/tutorial/jdbc/overview/database.html|title=A Relational Database Overview|work=oracle.com}}</ref> Generally, each table/relation represents one \"entity type\" (such as customer or product). The rows represent instances of that type of entity (such as \"Lee\" or \"chair\") and the columns representing values attributed to that instance (such as address or price).\n\n== Keys ==\n\nEach row in a table has its own unique key. Rows in a table can be linked to rows in other tables by adding a column for the unique key of the linked row (such columns are known as foreign keys). Codd showed that data relationships of arbitrary complexity can be represented by a simple set of concepts.\n\nPart of this processing involves consistently being able to select or modify one and only one row in a table. Therefore, most physical implementations have a unique primary key for each table. When a new row is written to the table, a new unique value for the [[primary key]] (PK) is generated; this is the key that the system uses primarily for accessing the table. System performance is optimized for PKs. Other, more [[natural key]]s may also be identified and defined as [[alternate key]]s (AK). Often several columns may be needed to form an AK (this is one reason why a single integer column is usually made the PK). Both PKs and AKs have the ability to uniquely identify one row within a table. Additional technology may be applied that will significantly assure a unique ID across the world, a [[globally unique identifier]]; these are used when there are broader system requirements.\n\nThe primary keys within a database are used to define the relationships among the tables. When a PK migrates to another table, it becomes a [[foreign key]] in the other table. When each cell can contain only one value and the PK migrates into a regular entity table, this design pattern can represent either a one-to-one, or a one-to-many relationship. Most relational database designs resolve many-to-many relationships by creating an additional table that contains the PKs from both of the other entity tables\u2014the relationship becomes an entity; the resolution table is then named appropriately and the two FKs are combined to form a PK. The migration of PKs to other tables is the second major reason why system-assigned integers are used normally as PKs; there usually is neither efficiency nor clarity in migrating a bunch of other types of columns.\n\n=== Relationships ===\nRelationships are a logical connection between different tables. A relationship is established on the basis of interaction among these tables.\n\n== Transactions ==\nIn order for a database management system (DBMS) to operate efficiently and accurately, it must have [[ACID transactions]].<ref>{{\ncite web\n|url=http://www.microsoft.com/presspass/features/1998/11-23gray.mspx\n|title=Gray to be Honored With A. M. Turing Award This Spring\n|date=1998-11-23\n|accessdate=2009-01-16\n|publisher= Microsoft PressPass | archiveurl = http://web.archive.org/web/20090206084720/http://www.microsoft.com/presspass/features/1998/11-23gray.mspx| archivedate= 6 February 2009 <!--DASHBot-->| deadurl= no}}</ref><ref>{{cite conference | first = Jim | last = Gray | authorlink = Jim Gray (computer scientist) | title = The Transaction Concept: Virtues and Limitations | booktitle = Proceedings of the 7th International Conference on Very Large Databases | pages = 144\u2013154 | publisher = [[Tandem Computers]] | date = September 1981 | location = 19333 Vallco Parkway, Cupertino CA 95014 | url = http://research.microsoft.com/~gray/papers/theTransactionConcept.pdf |format=PDF| accessdate = 2006-11-09 }}</ref><ref>Gray, Jim, and Reuter, Andreas, ''Distributed Transaction Processing: Concepts and Techniques''. [[Morgan Kaufmann]], 1993. ISBN 1-55860-190-2.</ref> \n\n== Stored procedures ==\n\nMost of the programming within a RDBMS is accomplished using [[Stored procedure|stored procedures (SPs)]]. Often procedures can be used to greatly reduce the amount of information transferred within and outside of a system. For increased security, the system design may also grant access to only the stored procedures and not directly to the tables. Fundamental stored procedures contain the logic needed to insert new data and update existing data. More complex procedures may be written to implement additional rules and logic related to processing or selecting the data.\n\n==Terminology==\n[[Image:Relational database terms.svg|350px|thumb|right|Relational database terminology.]]\nThe relational database was first defined in June 1970 by [[E.F. Codd|Edgar Codd]], of IBM's [[IBM Almaden Research Center|San Jose Research Laboratory]].<ref name=codd>{{cite journal|last=Codd|first=E.F.|year=1970|title=A Relational Model of Data for Large Shared Data Banks|url=|journal=[[Communications of the ACM]]|volume=13|issue=6|pages=377\u2013387|doi=10.1145/362384.362685}}</ref>  Codd's view of what qualifies as an RDBMS is summarized in [[Codd's 12 rules]]. A relational database has become the predominant type of database.  Other models besides the ''relational model'' include the [[hierarchical database model]] and the [[network model]].\n\nThe table below summarizes some of the most important relational database terms and the corresponding [[SQL]] term:\n\n{| class=\"wikitable\"\n|-\n! SQL term\n! Relational database term\n! Description\n|-\n| [[Row (database)|'''''Row''''']]\n| '''''[[Tuple]]''''' or [[Record (computer science)|'''''record''''']]\n| A data set representing a single item\n|-\n| [[Column (database)|'''''Column''''']]\n| '''''Attribute''''' or '''''field'''''\n| A labeled element of a tuple, e.g. \"Address\" or \"Date of birth\"\n|- \n| [[Table (database)|'''''Table''''']]\n| [[Relation (database)|'''''Relation''''']] or '''''Base [[relvar]]'''''\n| A set of tuples sharing the same attributes; a set of columns and rows\n|-\n| [[View (SQL)|'''''View''''']] or '''''[[result set]]'''''\n| '''''Derived relvar'''''\n| Any set of tuples; a data report from the RDBMS in response to a [[query language|query]]\n|}\n\n==Relations or tables==\n{{main|Relation (database)|Table (database)}}\nA ''[[relation (database)|relation]]'' is defined as a set of [[tuple]]s that have the same [[Attribute (computing)|attributes]]. A tuple usually represents an object and information about that object. Objects are typically physical objects or concepts. A relation is usually described as a [[Table (database)|table]], which is organized into [[Row (database)|rows]] and [[Column (database)|columns]]. All the data referenced by an attribute are in the same [[Domain (mathematics)|domain]] and conform to the same constraints.\n\nThe relational model specifies that the tuples of a relation have no specific order and that the tuples, in turn, impose no order on the attributes. Applications access data by specifying queries, which use operations such as ''select'' to identify tuples, ''project'' to identify attributes, and ''join'' to combine relations. Relations can be modified using the ''insert'', ''delete'', and ''update'' operators. New tuples can supply explicit values or be derived from a query. Similarly, queries identify tuples for updating or deleting.\n\nTuples by definition are unique. If the tuple contains a [[candidate key|candidate]] or primary key then obviously it is unique; however, a primary key need not be defined for a row or record to be a tuple. The definition of a tuple requires that it be unique, but does not require a primary key to be defined. Because a tuple is unique, its attributes by definition constitute a [[superkey]].\n\n==Base and derived relations==<!-- This section is linked from [[Relational database]] -->\n{{main|Relvar|View (database)}}\nIn a relational database, all data are stored and accessed via [[relation (database)|relation]]s. Relations that store data are called \"base relations\", and in implementations are called \"tables\". Other relations do not store data, but are computed by applying relational operations to other relations. These relations are sometimes called \"derived relations\". In implementations these are called \"[[View (database)|views]]\" or \"queries\". Derived relations are convenient in that they act as a single relation, even though they may grab information from several relations. Also, derived relations can be used as an [[abstraction layer]].\n\n===Domain===\n{{main|data domain}}\nA domain describes the set of possible values for a given attribute, and can be considered a constraint on the value of the attribute. Mathematically, attaching a domain to an attribute means that any value for the attribute must be an element of the specified set.\nThe character string ''\"ABC\"'', for instance, is not in the integer domain, but the integer value ''123'' is. Another example of domain describes the possible values for the field \"Gender\" as (\"Male,\"Female\"). So, the field \"Gender\" will not accept input values like (0.1) or (M,F).\n\n==Constraints==\nConstraints make it possible to further restrict the domain of an attribute. For instance, a constraint can restrict a given integer attribute to values between 1 and 10. Constraints provide one method of implementing [[business rules]] in the database. SQL implements constraint functionality in the form of [[check constraint]]s.\nConstraints restrict the data that can be stored in [[relation (database)|relation]]s. These are usually defined using expressions that result in a <!-- do not change the capitalization of this link without first consulting, and replying to the talk page. Any such edits will be reverted. -->[[Boolean data type|boolean]] value, indicating whether or not the data satisfies the constraint. Constraints can apply to single attributes, to a tuple (restricting combinations of attributes) or to an entire relation.\nSince every attribute has an associated domain, there are constraints ('''domain constraints'''). The two principal rules for the relational model are known as '''entity integrity''' and '''referential integrity'''.\n\n===Primary key===\n{{main|Unique key}}\nA primary key uniquely specifies a tuple within a table. In order for an attribute to be a good primary key it must not repeat. While natural attributes (attributes used to describe the data being entered) are sometimes good primary keys, [[surrogate key]]s are often used instead. A surrogate key is an artificial attribute assigned to an object which uniquely identifies it (for instance, in a table of information about students at a school they might all be assigned a student ID in order to differentiate them). The surrogate key has no intrinsic (inherent) meaning, but rather is useful through its ability to uniquely identify a tuple.\nAnother common occurrence, especially in regard to N:M cardinality is the [[Compound key|composite key]]. A composite key is a key made up of two or more attributes within a table that (together) uniquely identify a record. (For example, in a database relating students, teachers, and classes.  Classes ''could'' be uniquely identified by a composite key of their room number and time slot, since no other class could have exactly the same combination of attributes. In fact, use of a composite key such as this can be a form of [[data verification]], albeit a weak one.\n\n===Foreign key===\n{{main|Foreign key}}\nA foreign key is a field in a relational table that matches the primary key column of another table. The foreign key can be used to cross-reference tables. Foreign keys do not need to have unique values in the referencing relation. Foreign keys effectively use the values of attributes in the referenced relation to restrict the domain of one or more attributes in the referencing relation.\nA foreign key could be described formally as: \"For all tuples in the referencing relation projected over the referencing attributes, there must exist a tuple in the referenced relation projected over those same attributes such that the values in each of the referencing attributes match the corresponding values in the referenced attributes.\"\n\n===Stored procedures===\n{{main|Stored procedure}}\nA stored procedure is executable code that is associated with, and generally stored in, the database. Stored procedures usually collect and customize common operations, like inserting a [[tuple]] into a [[relation (database)|relation]], gathering statistical information about usage patterns, or encapsulating complex [[business logic]] and calculations. Frequently they are used as an [[application programming interface]] (API) for security or simplicity. Implementations of stored procedures on SQL RDBMSs often allow developers to take advantage of [[Procedural programming|procedural]] extensions (often vendor-specific) to the standard [[Declarative programming|declarative]] SQL syntax.\nStored procedures are not part of the relational database model, but all commercial implementations include them.\n\n===Index===\n{{main|Index (database)}}\nAn index is one way of providing quicker access to data. Indices can be created on any combination of attributes on a [[relation (database)|relation]]. Queries that filter using those attributes can find matching tuples randomly using the index, without having to check each tuple in turn. This is analogous to using the [[Index (publishing)|index of a book]] to go directly to the page on which the information you are looking for is found, so that you do not have to read the entire book to find what you are looking for. Relational databases typically supply multiple indexing techniques, each of which is optimal for some combination of data distribution, relation size, and typical access pattern. Indices are usually implemented via [[B+ tree]]s, [[R-tree]]s, and [[Bitmap index|bitmaps]].\nIndices are usually not considered part of the database, as they are considered an implementation detail, though indices are usually maintained by the same group that maintains the other parts of the database. It should be noted that use of efficient indexes on both primary and foreign keys can dramatically improve query performance. This is because B-tree indexes result in query times proportional to log(n) where n is the number of rows in a table and hash indexes result in constant time queries (no size dependency as long as the relevant part of the index fits into memory).\n\n==Relational operations==\n{{main|Relational algebra}}\nQueries made against the relational database, and the derived [[relvars]] in the database are expressed in a [[relational calculus]] or a [[relational algebra]]. In his original relational algebra, Codd introduced eight relational operators in two groups of four operators each. The first four operators were based on the traditional mathematical [[Set theory|set operations]]:\n* The [[Union (set theory)|union]] operator combines the tuples of two [[relation (database)|relation]]s and removes all duplicate tuples from the result. The relational union operator is equivalent to the [[Union (SQL)|SQL UNION]] operator.\n* The [[Intersection (set theory)|intersection]] operator produces the set of tuples that two relations share in common. Intersection is implemented in SQL in the form of the [[Intersect (SQL)|INTERSECT]] operator.\n* The [[Complement (set theory)|difference]] operator acts on two relations and produces the set of tuples from the first relation that do not exist in the second relation. Difference is implemented in SQL in the form of the [[Except (SQL)|EXCEPT]] or MINUS operator.\n* The [[cartesian product]] of two relations is a join that is not restricted by any criteria, resulting in every tuple of the first relation being matched with every tuple of the second relation. The cartesian product is implemented in SQL as the [[Cross join|CROSS JOIN]] operator.\nThe remaining operators proposed by Codd involve special operations specific to relational databases:\n* The selection, or restriction, operation retrieves tuples from a relation, limiting the results to only those that meet a specific criterion, i.e. a [[subset]] in terms of set theory. The SQL equivalent of selection is the [[Select (SQL)|SELECT]] query statement with a [[Where (SQL)|WHERE]] clause.\n* The [[Projection (relational algebra)|projection operation]] extracts only the specified attributes from a tuple or set of tuples.\n* The join operation defined for relational databases is often referred to as a natural join. In this type of join, two relations are connected by their common attributes. MySQL's approximation of a natural join is the [[Inner join|INNER JOIN]] operator. In SQL, an INNER JOIN prevents a cartesian product from occurring when there are two tables in a query. For each table added to an SQL Query, one additional INNER JOIN is added to prevent a cartesian product. Thus, for N tables in an SQL query, there must be N-1 INNER JOINS to prevent a cartesian product.\n* The [[Relational algebra#Division|relational division]] operation is a slightly more complex operation and essentially involves using the tuples of one relation (the dividend) to partition a second relation (the divisor). The relational division operator is effectively the opposite of the cartesian product operator (hence the name).\nOther operators have been introduced or proposed since Codd's introduction of the original eight including relational comparison operators and extensions that offer support for nesting and hierarchical data, among others.\n\n==Normalization==\n{{main|Database normalization}}\nNormalization was first proposed by Codd as an integral part of the relational model. It encompasses a set of procedures designed to eliminate non-simple domains (non-atomic values) and the redundancy (duplication) of data, which in turn prevents data manipulation anomalies and loss of data integrity.  The most common forms of normalization applied to databases are called the [[Database normalization#Normal forms|normal form]]s.\n\n==Distributed relational databases==\n\n[[DRDA|Distributed Relational Database Architecture]] (DRDA) was designed by a work group within IBM in the period 1988 to 1994. DRDA enables network connected relational databases to cooperate to fulfill SQL requests.\n<ref>{{cite journal|last1=Reinsch, R.|title=Distributed database for SAA|journal=IBM Systems Journal|date=1988|volume=27|issue=3|pages=362\u2013389|doi=10.1147/sj.273.0362}}</ref>\n<ref>{{cite book|title=Distributed Relational Database Architecture Reference|date=1990|publisher=IBM Corp. SC26-4651-0}}</ref> \nThe messages, protocols, and structural components of DRDA are defined by the [[Distributed Data Management Architecture]].\n\n==References==\n{{Reflist|30em}}\n\n{{Databases}}\n\n{{DEFAULTSORT:Relational Database}}\n[[Category:Relational model| ]]\n[[Category:Database theory]]\n[[Category:Types of databases]]\n[[Category:English inventions]]\n[[Category:1969 introductions]]"}]}}}}