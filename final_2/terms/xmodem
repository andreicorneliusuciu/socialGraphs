{"batchcomplete":"","query":{"pages":{"1117757":{"pageid":1117757,"ns":0,"title":"XMODEM","revisions":[{"contentformat":"text/x-wiki","contentmodel":"wikitext","*":"{{multiple issues|\n{{primary sources|date=April 2013}}\n{{More footnotes|date=January 2009}}\n}}\n\n{{Infobox networking protocol\n|       title = XMODEM\n|        logo = \n|    logo alt = \n|       image = \n|   image alt = \n|     caption = \n|    is stack = \n|     purpose = file transfer protocol\n|   developer = [[Ward Christensen]]<ref>[https://books.google.com.au/books?id=9eJxx_ZGKngC&lpg=PA451&dq=%22Ward%20Christensen%22&pg=PA451#v=onepage&q=%22Ward%20Christensen%22&f=false Telecommunications: XMODEM: A Standard Is Born], By Alfred Glossbrenner, PC Mag, 17 April 1984, Page 451-452, ''... but the protocol itself was long ago placed in the public domain by its creator, Chicagoan Ward Christensen. Since its introduction in 1978, XMODEM ...''</ref><ref>[https://books.google.com.au/books?id=EzAEAAAAMBAJ&lpg=PA26&dq=%22Ward%20Christensen%22&pg=PA26#v=onepage&q=%22Ward%20Christensen%22&f=false In Focus: History lesson: Ward Christensen's free free-exchange software], By Michael Swaine, InfoWorld, 1 Nov 1982, Page 26</ref>\n|        date = {{Start date and age|  1977  |  |  }}<!--Fill in: Year (4 digits), month and day (2 digits)-->\n|    based on = \n|  influenced = [[YMODEM]], many others\n|    osilayer = \n|       ports = \n|        rfcs = \n|    hardware = [[modem]]s\n}}\n'''XMODEM''' is a simple [[file transfer]] protocol developed as a quick [[Hacker (hobbyist)|hack]] by [[Ward Christensen]] for use in his 1977 '''MODEM.ASM''' [[terminal program]]. It allowed users to transmit files between their computers when both sides used MODEM. Keith Petersen made a minor update to always turn on \"quiet mode\", and called the result XMODEM.<ref>Ward Christensen, [http://www.bbsdocumentary.com/software/AAA/AAA/CBBS/memories.txt \"Memories\"], 25 November 1992</ref>\n\nXMODEM became extremely popular in the early [[bulletin board system]] (BBS) market, largely because it was so simple to implement. It was also fairly inefficient, and as modem speeds increased this problem led to the development of a number of modified versions of XMODEM to improve performance or address other problems with the protocol. Christensen believed his original XMODEM to be \"the single most modified program in computing history\".<ref>{{cite web|url=http://www.well.com/user/hlr/vcbook/vcbook4.html|title=The Virtual Community}}</ref> [[Chuck Forsberg]] collected a number of modifications into his [[YMODEM]] protocol, but poor implementation led to a further fracturing before they were re-unified by his later [[ZMODEM]] protocol.\n\nXMODEM, like most file transfer protocols, breaks up the original data into a series of \"[[Packet (information technology)|packets]]\" that are sent to the receiver, along with additional information allowing the receiver to determine whether that packet was correctly received.\n\n==Packet structure==\n\nThe original XMODEM used a 128-byte data packet, the basic block size used on [[CP/M]] [[floppy disk]]s. The packet was prefixed by a simple 3-byte header containing a <tt><[[C0 and C1 control codes|SOH]]></tt> character, a \"block number\" from 0-255, and the \"inverse\" block number\u2014255 minus the block number. Block numbering starts with 1 for the first block sent, not 0.\n\nThe packet was also suffixed with a single-byte [[checksum]] of the data bytes. The checksum was the sum of all bytes in the packet [[modulo operation|modulo]] 256. The modulo operation was easily computed by discarding all but the eight [[least significant bit]]s of the result, or alternatively on an eight bit machine, ignoring [[arithmetic overflow]] which would produce the same effect automatically. In this way the checksum was restricted to an eight bit quantity which was able to be expressed using a single byte. For example, if this checksum method was used on a tiny data packet containing only two bytes carrying the values 130 and 130, the total of these codes is 260 and the resulting checksum is 4.\n\nThe complete packet was thus 132 bytes long, containing 128 bytes of [[Payload (computing)|payload data]], for a total [[channel efficiency]] of about 97%.\n\nThe file was marked \"complete\" with a <tt><[[End-of-transmission character|EOT]]></tt> character sent after the last block. This character was not in a packet, but sent alone as a single byte. Since the file length was not sent as part of the protocol, the last packet was padded out with a \"known character\" that could be dropped. In the original specification this defaulted to <tt><nowiki><SUB></nowiki></tt> or 26 decimal, which CP/M used as the end-of-file marker inside its own disk format. The standard suggested any character could be used for padding, but there was no way for it to be changed ''within the protocol'' itself \u2013 if an implementation changed the padding character, only clients using the same implementation would correctly interpret the new padding character.\n\n==Transfer details==\n\nFiles were transferred one packet at a time. When received, the packet's checksum was calculated by the receiver and compared to the one received from the sender at the end of the packet. If the two matched, the receiver sent an <tt><[[Acknowledge character|ACK]]></tt> message back to the sender, which then sent the next packet in sequence. If there was a problem with the checksum, the receiver instead sent a <tt><[[Negative acknowledge character|NAK]]></tt>. If a <tt><NAK></tt> was received, the sender would re-send the packet, and continued to try several times, normally ten, before aborting the transfer.\n\nA <tt><NAK></tt> was also sent if the receiver did not receive a valid packet within ten seconds while still expecting data due to the lack of a <tt><EOT></tt> character. A seven-second timeout was also used ''within'' a packet, guarding against dropped connections in mid-packet.\n\nThe block numbers were also examined in a simple way to check for errors. After receiving a packet successfully, the next packet should have a one-higher number. If it instead received the same block number this was not considered serious, it was implied that the <tt><ACK></tt> had not been received by the sender, which had then re-sent the packet.\n\nTransfers were receiver-driven; the transmitter would not send any data until an initial <tt><NAK></tt> was sent by the receiver. This was a logical outcome of the way the user interacted with the sending machine, which would be remotely located. The user would navigate to the requested file on the sending machine, and then ask that machine to transfer it. Once this command was issued, the user would then execute a command in their local software to start receiving. Since the delay between asking the remote system for the file and issuing a local command to receive was unknown, XMODEM allowed up to 90 seconds for the receiver to begin issuing requests for data packets.\n\n==Problems==\nAlthough XMODEM was robust enough for a journalist in 1982 to transmit stories from Pakistan to the United States with an [[Osborne 1]] and [[acoustic coupler]] over poor-quality telephone lines,<ref name=\"kline198207\">{{cite news | url=https://archive.org/stream/kilobaudmagazine-1982-07/Microcomputing_1982_July#page/n43/mode/2up | title=Osborne\u2014Behind Guerrilla Lines | work=Microcomputing | date=July 1982 | accessdate=15 February 2016 | author=Kline, David | pages=42-50}}</ref> the protocol had several flaws.\n\n===Minor problems===\n\nXMODEM was written for [[CP/M]] machines, and bears several marks of that [[operating system]]. Notably, files on CP/M were always multiples of 128 bytes, and their end was marked within a block with the <tt><EOT></tt> character. These characteristics were transplanted directly into XMODEM. However, other operating systems did not feature either of these peculiarities, and the widespread introduction of [[MS-DOS]] in the early 1980s led to XMODEM having to be updated to notice either a <tt><EOT></tt> ''or'' <tt><EOF></tt> as the end-of-file marker.\n\nFor some time it was suggested that sending a <tt><CAN></tt> character instead of an <tt><ACK></tt> or <tt><NAK></tt> should be supported in order to easily abort the transfer from the receiving end. Likewise, a <tt><CAN></tt> received in place of the <tt><SOH></tt> indicated the sender wished to cancel the transfer. However, this character could be easily \"created\" via simple noise-related errors of what was meant to be an <tt><ACK></tt> or <tt><NAK></tt>. A double-<tt><CAN></tt> was proposed to avoid this problem, but it is not clear if this was widely implemented.\n\n===Major problems===\n\nXMODEM was designed for simplicity, without much knowledge of other file transfer protocols \u2013 which were fairly rare anyway. Due to its simplicity, there were a number of very basic errors that could cause a transfer to fail, or worse, result in an incorrect file which went unnoticed by the protocol. Most of this was due to the use of a simple checksum for error correction, which is susceptible to missing errors in the data if ''two'' bits are reversed, which can happen with a suitably short burst of noise. Additionally, similar damage to the header or checksum could lead to a failed transfer in cases where the data itself was undamaged.\n\nMany authors introduced extensions to XMODEM to address these and other problems. Many asked for these extensions to be included as part of a new XMODEM standard. However, Ward Christensen refused to do this, as it was precisely the ''lack'' of these features, and the associated coding needed to support them, that led to XMODEM's widespread use. As he explained:\n\n:It was a quick hack I threw together, very unplanned (like everything I do), to satisfy a personal need to communicate with some other people. ONLY the fact that it was done in 8/77, and that I put it in the public domain immediately, made it become the standard that it is...\n:...People who suggest I make SIGNIFICANT changes to the protocol, such as 'full duplex', 'multiple outstanding blocks', 'multiple destinations', etc etc don't understand that the incredible simplicity of the protocol is one of the reasons it survived.\n\n==Batch Transfers==\nAnother problem with XMODEM was that it required the transfer to be user-driven. Typically this meant the user would navigate on the sender's system to select the file they wanted, and then invoke the transfer from their end using a command in their terminal emulator. If the user wanted to transfer another file, they would have to repeat this process again.\n\nFor automated transfers between two sites, a number of add-ons to the XMODEM protocol were implemented over time. These generally assumed the sender would continue sending file after file, with the receiver attempting to trigger the next file by sending a <tt><NAK></tt> as normal at the start of a transfer. When the <tt><NAK></tt>'s timed out, it could be assumed that either there were no more files, or the link was broken anyway.\n\n===MODEM7===\n'''MODEM7''', also known as '''MODEM7 batch''' or '''Batch XMODEM''', was the first known extension of the XMODEM protocol. A normal XMODEM file transfer starts with the receiver sending a single <tt><NAK></tt> character to the sender, which then starts sending a single <tt><SOH></tt> to indicate the start of the data, and then packets of data.\n\nMODEM7 changed this behaviour only slightly, by sending the filename, in [[8.3 filename]] format, before the <tt><SOH></tt>. Each character was sent individually and had to be echoed by the receiver as a form of error correction. For a non-aware XMODEM implementation, this data would simply be ignored while it waited for the <tt><SOH></tt> to arrive, so the characters would not be echoed and the implementation could fall back to conventional XMODEM. With \"aware\" software, the file name could be used to save the file locally. Transfers could continue with another <tt><NAK></tt>, each file being saved under the name being sent to the receiver.\n\n[[Jerry Pournelle]] in 1983 described MODEM7 as \"probably the most popular microcomputer communications program in existence\".<ref name=\"pournelle198307\">{{cite news | url=https://archive.org/stream/byte-magazine-1983-07-rescan/1983_07_BYTE_08-07_Videotex#page/n325/mode/2up | title=Interstellar Drives, Osborne Accessories, DEDICATE/32, and Death Valley | work=BYTE | date=July 1983 | accessdate=28 August 2016 | author=Pournelle, Jerry | pages=323}}</ref>\n\n===TeLink===\nMODEM7 sent the filename as normal text, which meant it could be corrupted by the same problems that XMODEM was attempting to avoid. This led to the introduction of '''TeLink''' by [[Tom Jennings]], author of the original [[FidoNet]] mailers.\n\nTeLink avoided MODEM7's problems by standardizing a new \"zero packet\" containing information about the original file. This included the file's name, size, and [[timestamp]], which were placed in a regular 128 byte XMODEM block. Whereas a normal XMODEM transfer would start with the sender sending \"block 1\", the TeLink header packet was labeled \"block 0\".\n\nAgain, a normal XMODEM implementation would simply discard the packet, the assumption being that the packet number had been corrupted. But this led to a potential time delay if the packet were discarded, as the sender could not tell whether it the receiver had responded with a <tt><NAK></tt> because it did not understand the \"block 0\" or because there was a transmission error. However, TeLink was generally limited to [[FidoNet]] software, which demanded it as part of the FidoNet standards. During early stages of FidoNet's development, the \"mailer\" programs called each other at known times early in the morning, when it was safe to assume the receiver was another mailer that also implemented TeLink.\n\nThe basic \"block 0\" system became a standard in the FidoNet community, and was re-used by a number of future protocols like [[SEAlink]] and [[YMODEM]].\n\n==XMODEM-CRC==\nThe checksum used in the original protocol was extremely simple, and errors within the packet could go unnoticed. This led to the introduction of '''XMODEM-CRC''' by John Byrns,<ref>{{cite web\n| url = http://www.techheap.com/communication/modems/xmodem.html\n| title = XMODEM Protocol Overview\n| first = Ward\n| last = Christensen\n| authorlink = Ward Christensen\n| date = 1 January 1982\n}}</ref><ref>{{cite web\n| url = http://www.techheap.com/communication/modems/xmodem-ymodem_reference.html\n| title = XMODEM/YMODEM PROTOCOL REFERENCE\n| first = Chuck\n| last = Forsberg\n| authorlink = Chuck Forsberg\n| date = 11 September 1986\n}}</ref> which used a 16-bit [[Cyclic redundancy check|CRC]] in place of the 8-bit checksum. CRC's encode not only the data in the packet, but its location as well, allowing it to notice the bit-replacement errors that a checksum would miss. Statistically, this made the chance of detecting an error less than 16 bits long 99.9969%, and even higher for longer error bit strings.{{fact|date=March 2016}}\n\nXMODEM-CRC was designed to be backwardly compatible with XMODEM. To do this, the receiver simply sent a <tt>C</tt> (capital C) character instead of a <tt><NAK></tt> to start the transfer. If the sender responded by sending a packet, it was assumed the sender \"knew\" XMODEM-CRC, and the receiver continued sending <tt>C</tt>'s. If no packet was forthcoming, the receiver assumed the sender did not know the protocol, and sent an <tt><NAK></tt> to start a \"traditional\" XMODEM transfer.\n\nUnfortunately this attempt at backward compatibility had a downside. Since it was possible that the initial <tt>C</tt> character would be lost or corrupted, it could not be assumed that the receiver did not support XMODEM-CRC if the first attempt to trigger the transfer failed. The receiver thus tried to start the transfer three times with <tt>C</tt>, waiting three seconds between each attempt. This meant that if the user selected XMODEM-CRC while attempting to talk to ''any'' XMODEM, as it was intended, there was a potential 10 second delay before the transfer started.\n\nTo avoid the delay, the sender and receiver would generally list XMODEM-CRC separately from XMODEM, allowing the user to select \"basic\" XMODEM if the sender didn't explicitly list it. Ironically, any software that ''did'' support -CRC in their basic XMODEM transfer, as it was intended, surreptitiously suggested the user should not attempt to use -CRC. To the average user, XMODEM-CRC was essentially a \"second protocol\", and treated as such.\n\n==Higher throughput==\nSince the XMODEM protocol required the sender to stop and wait for an <tt><ACK></tt> or <tt><NAK></tt> message from the receiver, it tended to be quite slow. In the era of 300 bit/s modems, the entire 132-byte packet required just over 3.5 seconds to send (132 bytes * 8 bits per byte / 300 bits per second). If it then took 0.2 seconds for the receiver's <tt><ACK></tt> to make it back to the sender and the next packet to start hitting the receiver (0.1 seconds in both directions), the overall time for one packet would be 3.7&nbsp;seconds, just over 92% throughput.\n\nAs modem speeds increased, the fixed delay needed to send the <tt><ACK></tt>/<tt><NAK></tt> grows in proportion to time needed to send the packet. For instance, at 2400&nbsp;bit/s the packets took only 0.44&nbsp;seconds to send, so if the <tt><ACK></tt>/<tt><NAK></tt> still took 0.2&nbsp;seconds to make it back (this is ''latency'' in the network, not throughput), the throughput has fallen to under 60%. At 9600&nbsp;bit/s it is under 30% \u2013 more time is spent waiting for the reply than is needed to send the packet.\n\nA number of new versions of XMODEM were introduced in order to address these problems. Like earlier extensions, these versions tended to be backward-compatible with the original XMODEM, and like those extensions, this led to a further fracturing of the XMODEM landscape in the user's terminal emulator. In the end, dozens of versions of XMODEM would emerge.\n\n===SEAlink===\nOne of the first third party mailers for the [[FidoNet]] system was '''SEAdog''', written by the same author as the then-popular [[.arc]] [[data compression]] format. SEAdog included a wide variety of improvements, including [[SEAlink]], an improved transfer protocol.\n\nSEAlink used a method known as ''[[sliding window]]s'' to avoid the inter-packet delay. To do this, the protocol did not wait for the <tt><ACK></tt>/<tt><NAK></tt> to arrive, and immediately moved onto the next packet. It was only after a defined number of packets had been sent, the ''window'', that the protocol would stop and wait. If the <tt><ACK></tt> arrived before the window ended, the protocol would remove that packet from the window and add another. In this fashion the system, under ideal conditions, never reached the end of the window, and continued sending packets continually. In order for this to work, SEAlink needed to know which packet the receiver was <tt><ACK></tt>/<tt><NAK></tt>ing, which it did by appending the packet number to the <tt><ACK></tt> or <tt><NAK></tt> character.\n\nSEAlink later added a number of other improvements, and was a useful general-purpose protocol. However it remained rare outside the FidoNet world, and was rarely seen in user-facing software.\n\n===XMODEM-1K===\nAnother way to solve the throughput problem is to increase the packet size. Although the fundamental problem of latency remains, the speed at which it becomes a problem is higher. XMODEM-1K with 1024-byte packets was the most popular such solution. In this case, the throughput at 9600 bit/s is 81%, given the same assumptions as above.\n\nXMODEM-1K was an expanded version of XMODEM-CRC, which indicated the longer block size in the ''sender'' by starting a packet with the <tt><STX></tt> character instead of <tt><SOH></tt>. Like other backward-compatible XMODEM extensions, it was intended that a -1K transfer could be started with any implementation of XMODEM on the other end, backing off features as required.\n\nXMODEM-1K was originally one of the many improvements to XMODEM introduced by [[Chuck Forsberg]] in his [[YMODEM]] protocol. Forsberg suggested that the various improvements were optional, expecting software authors to implement as many of them as possible. Instead they generally implemented the bare minimum, leading to a profusion of semi-compatible implementations, and eventually, the splitting out of the name \"YMODEM\" into \"XMODEM-1K\" and a variety of YMODEMs. Thus XMODEM-1K actually post-dates YMODEM, but remained fairly common anyway.\n\nA backwards compatible extensions of XMODEM with 32k and 64k block lengths was created by Adontec for better performance on high-speed error free connections like ISDN or TCP/IP networks.\n\n===Pre-acknowledge===\nOver reliable (error-free) connections, the receiver could eliminate the latency issue by \"pre-acknowledging\" the packets. The receiver would already send <tt><ACK></tt> while the packet was still being transmitted. This effectively breaks error-correction since a packet is always acknowledged regardless of its integrity (which can only be checked after it has been completely received). Since this feature is only an alteration of the receiver-side behaviour, it does not require any changes in the protocol or on the sender's side.\n\nPre-acknowledge was also possible for [[YMODEM]]. It was made obsolete by variants such as YMODEM-g or [[ZMODEM]].\n\n===WXModem===\n'''WXmodem''', short for \"Windowed Xmodem\", is a variant of the [[Xmodem]] [[file transfer]] protocol developed by Peter Boswell optimized for high-[[Lag|latency]] data links.<ref>[https://github.com/cpeterso/wxmodem WXmodem 4 program and source code]</ref> It supports block sizes of up to 512 [[bytes]]. Xmodem uses stop and wait protocol while WXmodem uses sliding window protocol.\n\n==References==\n{{Reflist}}\n\n==External links==\n* [http://textfiles.com/programming/ymodem.txt XMODEM / YMODEM Protocol Reference by Chuck Forsberg], October 10, 1985\n* [http://pauillac.inria.fr/~doligez/zmodem/ymodem.txt XMODEM / YMODEM Protocol Reference by Chuck Forsberg], June 18, 1988 (document reformatted October 14, 1988) [https://web.archive.org/web/20121110151951/http://www.techfest.com/hardware/modem/xymodem.htm (HTML version with text issues)]\n* [http://wiki.synchro.net/ref:xmodem XMODEM / XMODEM-CRC / WXMODEM File Transfer Protocols], synchro.net\n* [http://www.adontec.com/xmodem_e.htm Adontec XMODEM/32k and XMODEM/64k extensions], adontec.com\n\n{{Modem file transfer protocols}}\n\n[[Category:BBS file transfer protocols]]\n[[Category:1977 introductions]]"}]}}}}