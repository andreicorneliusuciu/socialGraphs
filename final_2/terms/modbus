{"batchcomplete":"","query":{"normalized":[{"from":"modbus","to":"Modbus"}],"pages":{"654223":{"pageid":654223,"ns":0,"title":"Modbus","revisions":[{"contentformat":"text/x-wiki","contentmodel":"wikitext","*":"'''Modbus''' is a serial [[communications protocol]] originally published by [[Programmable logic controller#History|Modicon]] (now [[Schneider Electric]]) in 1979 for use with its [[programmable logic controller]]s (PLCs). Simple and robust, it has since become a ''[[de facto]]'' [[Standardization|standard]] communication protocol, and it is now a commonly available means of connecting industrial [[Electronics|electronic]] devices.<ref name=Drury2009>{{cite book |first=Bill |last=Drury |title=Control Techniques Drives and Controls Handbook |edition=2nd |date=2009 |publisher=[[Institution of Engineering and Technology]] |url=http://knovel.com/web/portal/browse/display?_EXT_KNOVEL_DISPLAY_bookid=2995&VerticalID=0 |format=PDF |pages=508\u2013 |subscription=yes}}</ref> The main reasons for the use of Modbus in the industrial environment are:\n* developed with industrial applications in mind\n* openly published and royalty-free\n* easy to deploy and maintain\n* moves raw bits or words without placing many restrictions on vendors\n\nModbus enables communication among many devices connected to the same network, for example a system that measures temperature and humidity and communicates the results to a [[computer]]. Modbus is often used to connect a supervisory computer with a [[remote terminal unit]] (RTU) in [[supervisory control and data acquisition]] ([[SCADA]]) systems. Many of the data types are named from its use in driving relays: a single-bit physical output is called a ''coil'', and a single-bit physical input is called a ''discrete input'' or a ''contact''.\n\nThe development and update of Modbus protocols has been managed by the Modbus Organization<ref name=\"Modbus home\">{{cite web |url=http://www.modbus.org/ |title=Modbus home page |website=Modbus |publisher=Modbus Organization, Inc. |accessdate=2 August 2013}}</ref> since April 2004, when Schneider Electric transferred rights to that organization.<ref>{{cite web |url=http://www.modbus.org/faq.php |title=Modbus FAQ |website=Modbus |publisher=Modbus Organization, Inc. |accessdate=1 November 2012}}</ref>  The Modbus Organization is an association of users and suppliers of Modbus compliant devices that seeks to drive the adoption and evolution of Modbus.<ref>{{cite web |url=http://www.modbus.org/about_us.php |title=About Modbus Organization |website=Modbus |publisher=Modbus Organization, Inc. |accessdate=8 November 2012}}</ref>\n\n== Modbus object types ==\n\nThe following is a table of object types provided by a modbus slave device to a modbus master device:\n{| class=\"wikitable\"\n! Object Type\n! Access\n! Size\n|-\n| Coil\n| Read-Write\n| 1-bit\n|-\n| Discrete Input\n| Read-Only\n| 1-bit\n|-\n| Input Register\n| Read-Only\n| 16-bits\n|-\n| Holding Register\n| Read-Write\n| 16-bits\n|}\n\n== Protocol versions ==\nVersions of the Modbus protocol exist for [[serial port]] and for [[Ethernet]] and other protocols that support the [[Internet protocol suite]]. There are many variants of Modbus protocols:\n* ''Modbus RTU'' \u2014 This is used in serial communication & makes use of a compact, binary representation of the data for protocol communication. The RTU format follows the commands/data with a [[cyclic redundancy check]] checksum as an error check mechanism to ensure the reliability of data. Modbus RTU is the most common implementation available for Modbus. A Modbus RTU message must be transmitted continuously without inter-character hesitations. Modbus messages are framed (separated) by idle (silent) periods.\n* ''Modbus [[ASCII]]'' \u2014 This is used in serial communication & makes use of ASCII characters for protocol communication. The ASCII format uses a [[longitudinal redundancy check]] checksum. Modbus ASCII messages are framed by leading colon (':') and trailing newline (CR/LF).\n* ''Modbus [[TCP/IP]] or Modbus TCP'' \u2014 This is a Modbus variant used for communications over TCP/IP networks, connecting over port 502.<ref name=modbustcp>Modbus Messaging on TCP/IP Implementation Guide V1.0b, s3.1.3</ref> It does not require a checksum calculation as lower layers already provide checksum protection.\n* ''Modbus over [[TCP/IP]] or Modbus over TCP or Modbus RTU/IP'' \u2014 This is a Modbus variant that differs from Modbus TCP in that a checksum is included in the payload as with Modbus RTU.<ref>[http://www.dmcinfo.com/Blog/articleType/ArticleView/articleId/71/Remote-Machine-MonitoringConnecting-to-a-Modbus-Network-with-Java-and-Jamod.aspx Remote Modbus Network Monitoring]</ref>\n* ''Modbus over [[User Datagram Protocol|UDP]]'' \u2014 Some have experimented with using Modbus over UDP on IP networks, which removes the overheads required for [[Transmission Control Protocol|TCP]] <ref>[http://jamod.sourceforge.net/kb/modbus_udp.html Java implementation]</ref>\n* ''Modbus Plus (Modbus+, MB+ or MBP)'' Modbus over [[Fieldbus]] (Modbus+ or MB+), also exists, but remains proprietary to [[Schneider Electric]]. requires a dedicated co-processor to handle fast [[High-Level Data Link Control|HDLC]]-like token rotation. It uses twisted pair at 1 Mbit/s and includes transformer isolation at each node, which makes it transition/edge triggered instead of voltage/level triggered. Special interfaces are required to connect Modbus Plus to a computer, typically a card made for the ISA (SA85), PCI or PCMCIA bus.\n* ''Modbus [[PEMEX]]''- This variant is an extension of standard Modbus with support for historical and flow data. It was designed for process control and never gained widespread adoption.\n* ''[[Enron]] Modbus''- This variant is an extension of standard Modbus with support for 32-bit Integer and Floating Point variables, and historical and flow data. Data types are mapped using standard addresses.<ref>http://www.simplymodbus.ca/Enron.htm</ref> The historical data serves to meet an [[American Petroleum Institute]] (API) industry standard for how data should be stored.\n\nData model and function calls are identical for the first 4 variants of protocols; only the encapsulation is different. However the variants are not interoperable as are the frame formats.\n\n== Communication and devices ==\nEach device intended to communicate using Modbus is given a unique address. In serial and MB+ networks, only the node assigned as the Master may initiate a command. On Ethernet, any device can send out a Modbus command, although usually only one master device does so. A Modbus command contains the Modbus address of the device it is intended for (1 to 247). Only the intended device will act on the command, even though other devices might receive it (an exception is specific broadcastable commands sent to node 0 which are acted on but not acknowledged). All Modbus commands contain checksum information, to allow the recipient to detect transmission errors. The basic Modbus commands can instruct an RTU to change the value in one of its registers, control or read an I/O port, and command the device to send back one or more values contained in its registers.\n\nThere are many modems and gateways that support Modbus, as it is a very simple protocol and often copied. Some of them were specifically designed for this protocol. Different implementations use wireline, wireless communication, such as in the [[ISM band]], and even [[Short Message Service]] (SMS) or [[General Packet Radio Service]] (GPRS). One of the more common designs of wireless networks makes use of [[mesh networking]]. Typical problems that designers have to overcome include high latency and timing issues.\n\n== Frame format ==\nA Modbus frame is composed of an Application Data Unit (ADU) which encloses a Protocol Data Unit (PDU):<ref>{{cite web|title=Modbus Messaging On TCP/IP Implementation Guide|url=http://www.modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf|website=Modbus Organization|publisher=Modbus-IDA|ref=MobusTCPSpec}}</ref>\n* ADU = Address + PDU + Error check\n* PDU = Function code + Data\nAll Modbus variants choose one of the following frame formats.<ref name=Drury2009 />\n\n{| class=\"wikitable\" style=\"float:middle; margin:0 0 1em 1em;\"\n|+ Modbus [[Remote Terminal Unit|RTU]] frame format (primarily used on 8-bit asynchronous lines like [[EIA-485]])\n|-\n! Name\n! Length (bits)\n! Function\n|-\n! Start\n| 28\n| At least {{frac|3|1|2}} character times of silence (mark condition)\n|-\n! Address\n| 8\n| Station address\n|-\n! Function\n| 8\n| Indicates the function code; e.g., read coils/holding registers\n|-\n! Data\n| ''n'' \u00d7 8\n| Data + length will be filled depending on the message type''\n|-\n! CRC\n| 16\n| [[Cyclic redundancy check]]\n|-\n! End\n| 28\n| At least {{frac|3|1|2}} character times of silence between frames\n|}\n\nNote about the [[Cyclic redundancy check|CRC]]:\n* Polynomial: x<sup>16</sup> + x<sup>15</sup> + x<sup>2</sup> + 1 (CRC-16-ANSI also known as CRC-16-IBM, normal hexadecimal algebraic polynomial being <code>8005</code> and reversed <code>A001</code>)\n* Initial value: 65,535\n* Example of frame in hexadecimal: <code>01 04 02 FF FF B8 80</code> (CRC-16-ANSI calculation from <code>01</code> to <code>FF</code> gives <code>80B8</code> which is transmitted '''least''' significant byte '''first''')\n\n{| class=\"wikitable\" style=\"float:middle; margin:0 0 1em 1em;\"\n|+ Modbus ASCII frame format (primarily used on 7- or 8-bit asynchronous serial lines)\n|-\n! Name\n! Length ([[byte]]s)\n! Function\n|-\n! Start\n| 1\n| Starts with colon <code>:</code> (ASCII hex value is <code>0x3a</code>)\n|-\n! Address\n| 2\n| Station address\n|-\n! Function\n| 2\n| Indicates the function codes like read coils / inputs\n|-\n! Data\n| ''n'' \u00d7 2\n| Data + length will be filled depending on the message type\n|-\n! LRC\n| 2\n| [[Checksum]] ([[Longitudinal redundancy check]])\n|-\n! End\n| 2\n| Carriage return \u2013 line feed (CR/LF) pair ([[ASCII]] values of 0x0d & 0x0a)\n|}\nAddress, function, data, and LRC are all capital hexadecimal readable pairs of characters representing 8-bit values (0\u2013255). For example, 122 (7x16+10) will be represented as <code>7A</code>.<br>\nLRC is calculated as the sum of 8-bit values, negated ([[two's complement]]) and encoded as an 8-bit value. Example: if address, function, and data encode as 247, 3, 19, 137, 0, and 10, their sum is 416. Two's complement (-416) trimmed to 8-bit is 96 (e.g. 256x2-416) which will be represented as <code>60</code> in hexadecimal. Hence the following frame <code>:F7031389000A60<CR><LF></code>\n{| class=\"wikitable\" style=\"float:middle; margin:0 0 1em 1em;\"\n|+ Modbus TCP frame format (primarily used on [[Ethernet]] networks)\n|-\n! Name\n! Length (bytes)\n! Function\n|-\n! Transaction identifier\n| 2\n| For synchronization between messages of server & client\n|-\n! Protocol identifier\n| 2\n| Zero for Modbus/TCP\n|-\n! Length field\n| 2\n| Number of remaining bytes in this frame\n|-\n! Unit identifier\n| 1\n| Slave address (255 if not used)\n|-\n! Function code\n| 1\n| Function codes as in other variants\n|-\n! Data bytes\n| n\n| Data as response or commands\n|}\n\nUnit identifier is used with Modbus/TCP devices that are composites of several Modbus devices, e.g. on Modbus/TCP to Modbus RTU gateways. In such case, the unit identifier tells the Slave Address of the device behind the gateway. Natively Modbus/TCP-capable devices usually ignore the Unit Identifier.\n\nThe byte order for values in Modbus data frames is [[Endianness|big-endian]] (MSB, Most Significant Byte of a value received first).\n\n== Supported function codes ==\nThe various reading, writing and other operations are categorised as follows.<ref>{{cite web |url=http://www.modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf |format=PDF |title=Modbus Application Protocol V1.1b3 |website=Modbus |publisher=Modbus Organization, Inc. |accessdate=2 August 2013}}</ref> The most primitive reads and writes are shown in bold. A number of sources use alternative terminology, for example ''Force Single Coil'' where the standard uses ''Write Single Coil''.<ref>{{cite book |first=Gordon |last=Clarke |first2=Deon |last2=Reynders |title=Practical Modern Scada Protocols: Dnp3, 60870.5 and Related Systems |url=https://books.google.com/books?id=ENqyW8fExswC&pg=PA45 |publisher=Newnes |date=2004 |isbn=0-7506-5799-5 |pages=47\u201351}}</ref><br>\nProminent entities within a Modbus slave are:\n* Coils: readable and writable, 1 bit (off/on)\n* Discrete Inputs: readable, 1 bit (off/on)\n* Input Registers: readable, 16 bits (0 to 65,535), essentially measurements and statuses\n* Holding Registers: readable and writable, 16 bits (0 to 65,535), essentially configuration values\n\n{| class=\"wikitable\"\n|+Modbus function codes\n|-\n!colspan=\"3\"|Function type||Function name||Function code\n|-\n|rowspan=\"13\"|Data Access||rowspan=\"4\"|Bit access||Physical Discrete Inputs||'''Read Discrete Inputs'''||2\n|-\n|rowspan=\"3\"|Internal Bits or Physical Coils||'''Read Coils'''||1\n|-\n|'''Write Single Coil'''||5\n|-\n|'''Write Multiple Coils'''||15\n|-\n|rowspan=\"7\"|16-bit access||Physical Input Registers||'''Read Input Registers'''||4\n|-\n|rowspan=\"6\"|Internal Registers or Physical Output Registers||'''Read Multiple Holding Registers'''||3\n|-\n|'''Write Single Holding Register'''||6\n|-\n|'''Write Multiple Holding Registers'''||16\n|-\n|Read/Write Multiple Registers||23\n|-\n|Mask Write Register||22\n|-\n|Read FIFO Queue||24\n|-\n|rowspan=\"2\" colspan=\"2\"|File Record Access||Read File Record||20\n|-\n|Write File Record||21\n|-\n|rowspan=\"6\" colspan=\"3\"|Diagnostics||Read Exception Status||7\n|-\n|Diagnostic||8\n|-\n|Get Com Event Counter||11\n|-\n|Get Com Event Log||12\n|-\n|Report Slave ID||17\n|-\n|Read Device Identification||43\n|-\n|colspan=\"3\"|Other||Encapsulated Interface Transport||43\n|}\n\n== Format of data of requests and responses for main function codes ==\nRequests and responses follow frame formats described above. This section gives details of data formats of most used function codes.\n\n=== Function code 1 (read coils) and function code 2 (read discrete inputs) ===\n'''Request''':\n*Address of first coil/discrete input to read (16-bit)\n*Number of coils/discrete inputs to read (16-bit)\n'''Normal response''':\n*Number of bytes of coil/discrete input values to follow (8-bit)\n*Coil/discrete input values (8 coils/discrete inputs per byte)\nValue of each coil/discrete input is binary (0 for off, 1 for on). First requested coil/discrete input is stored as least significant bit of first byte in reply.<br>\nIf number of coils/discrete inputs is not a multiple of 8, most significant bit(s) of last byte will be stuffed with zeros.<br>\nFor example, if eleven coils are requested, two bytes of values are needed. Suppose states of those successive coils are ''on, off, on, off, off, on, on, on, off, on, on'', then the response will be <code>02 E5 06</code> in hexadecimal.\n\n=== Function code 5 (force/write single coil) ===\n'''Request''':\n*Address of coil (16-bit)\n*Value to force/write: 0 for off and 65,280 (FF00 in hexadecimal) for on\n'''Normal response''': same as request.\n\n=== Function code 15 (force/write multiple coils) ===\n'''Request''':\n*Address of first coil to force/write (16-bit)\n*Number of coils to force/write (16-bit)\n*Number of bytes of coil values to follow (8-bit)\n*Coil values (8 coil values per byte)\nValue of each coil is binary (0 for off, 1 for on). First requested coil is stored as least significant bit of first byte in request.<br>\nIf number of coils is not a multiple of 8, most significant bit(s) of last byte should be stuffed with zeros. See example for function codes 1 and 2.<br>\n<br>\n'''Normal response''':\n*Address of first coil (16-bit)\n*number of coils (16-bit)\n\n=== Function code 4 (read input registers) and function code 3 (read holding registers) ===\n'''Request''':\n*Address of first register to read (16-bit)\n*Number of registers to read (16-bit)\n'''Normal response''':\n*Number of bytes of register values to follow (8-bit)\n*Register values (16 bits per register)\nBecause the number of bytes for register values is 8-bit wide, only 127 registers can be read at once.\n\n=== Function code 6 (preset/write single holding register) ===\n'''Request''':\n*Address of holding register to preset/write (16-bit)\n*New value of the holding register (16-bit)\n'''Normal response''': same as request.\n\n=== Function code 16 (preset/write multiple holding registers) ===\n'''Request''':\n*Address of first holding register to preset/write (16-bit)\n*Number of holding registers to preset/write (16-bit)\n*Number of bytes of register values to follow (8-bit)\n*New values of holding registers (16 bits per register)\nBecause register values are 2-bytes wide and only 127 bytes worth of values can be sent, only 63 holding registers can be preset/written at once.\n\n'''Normal response''':\n*Address of first preset/written holding register (16-bit)\n*number of preset/written holding registers (16-bit)\n\n=== Exception responses ===\nFor a normal response, slave repeats the function code. Should a slave want to report an error, it will reply with the requested function code plus 128 (3 becomes 131 or <code>83</code> in hexadecimal), and will only include one byte of data, known as the ''exception code''.\n\n=== Main Modbus exception codes ===\n{| class=\"wikitable\"\n|-\n! Code !! Text !! Details\n|-\n| 1 || Illegal Function || Function code received in the query is not recognized or allowed by slave\n|-\n| 2 || Illegal Data Address || Data address of some or all the required entities are not allowed or do not exist in slave\n|-\n| 3 || Illegal Data Value || Value is not accepted by slave\n|-\n| 4 || Slave Device Failure || Unrecoverable error occurred while slave was attempting to perform requested action\n|-\n| 5 || Acknowledge || Slave has accepted request and is processing it, but a long duration of time is required. This response is returned to prevent a timeout error from occurring in the master. Master can next issue a ''Poll Program Complete'' message to determine if processing is completed\n|-\n| 6 || Slave Device Busy || Slave is engaged in processing a long-duration command. Master should retry later\n|-\n| 7 || Negative Acknowledge || Slave cannot perform the programming functions. Master should request diagnostic or error information from slave\n|-\n| 8 || Memory Parity Error || Slave detected a parity error in memory. Master can retry the request, but service may be required on the slave device\n|-\n| 10 || Gateway Path Unavailable || Specialized for Modbus gateways. Indicates a misconfigured gateway\n|-\n| 11 || Gateway Target Device Failed to Respond || Specialized for Modbus gateways. Sent when slave fails to respond\n|}\n\n== Coil, discrete input, input register, holding register numbers and addresses ==\nSome conventions govern how access to Modbus entities (coils, discrete inputs, input registers, holding registers) are referenced.<br>\nIt is important to make a distinction between entity ''number'' and entity ''address'':\n*Entity ''numbers'' combine entity type and entity location within their description table\n*Entity ''address'' is the starting address, a 16-bit value in the data part of the Modbus frame. As such its range goes from 0 to 65,535\nIn the traditional standard, ''numbers'' for those entities start with a digit, followed by a number of four digits in range 1\u20139,999:\n* coils ''numbers'' start with a '''zero''' and then span from '''0'''0001 to '''0'''9999\n* discrete input ''numbers'' start with a '''one''' and then span from '''1'''0001 to '''1'''9999\n* input register ''numbers'' start with a '''three''' and then span from '''3'''0001 to '''3'''9999\n* holding register ''numbers'' start with a '''four''' and then span from '''4'''0001 to '''4'''9999\nThis translates into ''addresses'' between 0 and 9,998 in data frames.<br>\nFor example, in order to read holding registers starting at ''number'' 40001, corresponding ''address'' in the data frame will be 0 with a function code of 3 (as seen above). For holding registers starting at ''number'' 40100, ''address'' will be 99. Etc.<br>\nThis limits the number of ''addresses'' to 9,999 for each entity. A ''de facto'' referencing extends this to the maximum of 65,536.<ref>{{cite web|title=Modbus 101 - Introduction to Modbus|url=http://www.csimn.com/CSI_pages/Modbus101.html|publisher=Control Solutions, Inc.}}</ref><br>\nIt simply consists of adding one digit to the previous list:\n* coil ''numbers'' span from '''0'''00001 to '''0'''65536\n* discrete input ''numbers'' span from '''1'''00001 to '''1'''65536\n* input register ''numbers'' span from '''3'''00001 to '''3'''65536\n* holding register ''numbers'' span from '''4'''00001 to '''4'''65536\nWhen using the extended referencing, all ''number'' references must be exactly six digits. This avoids confusion between coils and other entities. For example, to know the difference between holding register #40001 and coil #40001, if coil #40001 is the target, it must appear as #040001.\n\n=== JBUS mapping ===\nAnother ''de facto'' protocol tightly related with Modbus appeared after it and was defined by PLC brand April Automates, resulting of a collaborative effort of French companies [[Renault]] Automation and [[Merlin Gerin]] et Cie in 1985:'''JBUS'''. Differences between Modbus and JBUS at that time (number of entities, slave stations) are now irrelevant as this protocol almost disappeared with April PLC series which AEG Schneider Automation bought in 1994 and then made them obsolete. However the name JBUS survived to some extent.\n\nJBUS supports function codes 1, 2, 3, 4, 5, 6, 15, and 16 and thus all the entities described above. However numbering is different with JBUS:\n*Number and address coincide: entity #x has address x in the data frame\n*Consequently, entity number does not include the entity type. For example, holding register #40010 in Modbus will be holding register #9, located at address 9 in JBUS\n*Number 0 (and thus address 0) is not supported. Slave should not implement any real data at this number and address and it can return a null value or throw an error when requested\n\n== Implementations ==\nAlmost all implementations have variations from the official standard. Different varieties might not communicate correctly between equipment of different suppliers. Some of the most common variations are:\n* Data types\n** [[Floating point]] IEEE\n** 32-bit integer\n** 8-bit data\n** Mixed data types\n** Bit fields in integers\n** Multipliers to change data to/from integer. 10, 100, 1000, 256 ...\n* Protocol extensions\n** 16-bit slave addresses\n** 32-bit data size (1 address = 32 bits of data returned)\n** Word swapped data\n\n== Limitations ==\n* Since Modbus was designed in the late 1970s to communicate to [[programmable logic controller]]s, the number of data types is limited to those understood by PLCs at the time. Large binary objects are not supported.\n* No standard way exists for a node to find the description of a data object, for example, to determine if a register value represents a temperature between 30 and 175 degrees.\n* Since Modbus is a master/slave protocol, there is no way for a field device to \"report by exception\" (except over Ethernet TCP/IP, called open-mbus)- the master node must routinely poll each field device, and look for changes in the data. This consumes bandwidth and network time in applications where bandwidth may be expensive, such as over a low-bit-rate radio link.\n* Modbus is restricted to addressing 254 devices on one data link, which limits the number of field devices that may be connected to a master station (once again Ethernet TCP/IP being an exception).\n* Modbus transmissions must be contiguous which limits the types of remote communications devices to those that can buffer data to avoid gaps in the transmission.\n* Modbus protocol itself provides no security against unauthorized commands or interception of data.<ref>{{cite conference |url= |title=Critical Infrastructure Protection III |first= |last= |date=23\u201325 March 2009 |conference=Third IFIP WG 11. 10 International Conference |editor-last=Palmer |editor2-first=Sujeet |editor2-last=Shenoi |publisher=Springer |location=Hanover, New Hampshire |isbn=3-642-04797-1 |page=87}}</ref>\n\n== Trade group ==\nModbus Organization, Inc. is a [[industry trade group|trade association]] for the promotion and development of Modbus protocol.<ref name=\"Modbus home\" />\n\n== Modbus Plus ==\nDespite the name, Modbus Plus<ref>{{cite web|url=http://www.schneider-electric.com/products/us/en/51900-networks-communication-and-radios/51940-fieldbus-and-core-networks/576-modbus-plus/ |title=Modbus Plus - Modbus Plus Network - Products overview - Schneider Electric United States |publisher=Schneider-electric.com |date= |accessdate=2014-01-03}}</ref> is not a variant of Modbus. It is a different [[Communications protocol|protocol]], involving [[token passing]].\n\nIt is a [[Proprietary protocol|proprietary specification]] of Schneider Electric, though it is unpublished rather than patented. It is normally implemented using a custom [[chipset]] available only to partners of Schneider. <!-- It is NOT compatible with simple [[RS-485]], despite some statements to the contrary. (Hidden because it seems to disagree with the reference)-->\n\n== References ==\n{{Reflist|30em}}\n\n== External links ==\n;Specification\n* [http://www.modbus.org/ Modbus Organization with protocol specifications]\n* ''[http://www.interlog.com/~speff/usefulinfo/modbus_protocol.pdf Modbus Protocol]'';  Modicon; 74 pages; 2000.\n;Other\n* [http://www.modbusbacnet.com/includes/pdf/MODBUS_2010Nov12.pdf Free Modbus Guide for Field Technician]\n* [http://www.globalmultimedia.in/modnet.htm Cost free Modbus RTU Device Testing Software]\n* [https://github.com/sourceperl/MBclient Perl module for Modbus/TCP]\n* [https://github.com/bashwork/pymodbus Pymodbus: Full Modbus protocol implementation in Python, free software]\n* [https://pypi.python.org/pypi/MinimalModbus MinimalModbus: Light RTU only Modbus implementation in Python]\n* [https://code.google.com/p/modbus-tk/ modbus-tk: Fast Modbus Implementation in Python]\n* [https://stackoverflow.com/questions/17081442/python-modbus-library Interesting Performance comparison of the 3 above mentioned python modules]\n* [http://wiki.tcl.tk/21150 Tcl based Modbus RTU driver]\n* [http://libmodbus.org Open Source C library of Modbus protocol for Linux, Mac OS X, FreeBSD, QNX and Win32]\n* [http://ibh-systems.com/modbus/slave/ Freeware Modbus Slave Simulator Application]\n* [http://www.hmisys.com/downloads/PeakHMISlaveSimulatorInstall.exe Free PeakHMI RTU, TCP/IP and ACSII slave simulators]\n* [http://jamod.sourceforge.net/ Jamod - Java library of Modbus protocol ]\n* [https://github.com/firatkucuk/modslave ModSlave - Modbus TCP Slave Device written in Python, Free Software]\n* [https://github.com/digitalpetri/modbus  digitalpetri Modbus - A modern, asynchronous Modbus implementation for Java]\n* [http://www.icsprotocols.com/ ICSProtocols \u2013 MODBUS TCP and RTU(Master/Slave) (requires email code activation)]\n\n{{Automation protocols}}\n{{Computer-bus}}\n\n[[Category:Industrial Ethernet]]\n[[Category:Industrial computing]]\n[[Category:Building automation]]\n[[Category:Automation]]\n[[Category:Network protocols]]"}]}}}}