{"batchcomplete":"","query":{"pages":{"29004":{"pageid":29004,"ns":0,"title":"SQL","revisions":[{"contentformat":"text/x-wiki","contentmodel":"wikitext","*":"{{About|the database language|the IATA code|San Carlos Airport (California)}}\n{{lead too short|date=June 2015}}\n{{cleanup reorganize|date=June 2015}}\n{{ infobox programming language\n| paradigm               = [[Multi-paradigm programming language|Multi-paradigm]]: [[declarative programming|declarative]]\n| year                   = 1974\n| family                 = [[Query language]]\n| designer               = [[Donald D. Chamberlin]]<br />[[Raymond F. Boyce]]\n| developer              = [[International Organization for Standardization|ISO]]/[[International Electrotechnical Commission|IEC]]\n| latest_release_version = [[SQL:2011]]\n| latest_release_date    = 2011\n| turing-complete        = No\n| typing                 = [[Static typing|Static]], [[strong typing|strong]]\n| implementations        = [[List of relational database management systems|Many]]\n| dialects               = SQL-86, SQL-89, [[SQL-92]], [[SQL:1999]], [[SQL:2003]], [[SQL:2006]], [[SQL:2008]], [[SQL:2011]]\n| influenced_by          = [[Datalog]]\n| influenced             = [[Common Query Language|CQL]], [[Language Integrated Query|LINQ]], [[Salesforce Object Query Language|SOQL]], [[Windows PowerShell]],<ref name=\"ars\" /> [[Java Persistence Query Language|JPQL]], [[Java Object Oriented Querying|jOOQ]]\n| operating_system       = [[Cross-platform]]\n| website                = \n| fileformat             = \n{{Infobox file format\n| child                  = yes\n| extension              = .sql\n| mime                   = application/sql<ref name=\"iana\" /><ref name=\"application/sql\" />\n| uniform type           =\n| owner                  = [[International Organization for Standardization|ISO]]/[[International Electrotechnical Commission|IEC]]\n| released               = {{Start date|1986|df=yes}}\n| latest release version = [[SQL:2011]]\n| latest release date    = {{Start date and age|2011|df=yes}}\n| genre                  = Database\n| standard               = ISO/IEC 9075\n| free                   = Yes\n| url                    = \n}}\n}}\n\n'''SQL''' ({{IPAc-en|audio=En-us-SQL.ogg|\u02c8|\u025b|s|_|k|ju\u02d0|_|\u02c8|\u025b|l}},<ref name=\"learningSQL\" /> or {{IPAc-en|audio=En-us-sequel.ogg|\u02c8|s|i\u02d0|k|w|\u0259|l}};<ref name=\"oed\" /> '''Structured Query Language'''<ref name=\"Britannica\" /><ref name=\"oed-US\" /><ref name=\"IBM-SQL\" /><ref name=\"MS-SQL-def\" />) is a [[special-purpose programming language]] designed for managing data held in a [[relational database management system]] (RDBMS), or for stream processing in a [[relational data stream management system]] (RDSMS).\n\nOriginally based upon [[relational algebra]] and [[tuple relational calculus]], SQL consists of a [[data definition language]], [[data manipulation language]], and [[Data Control Language]]. The scope of SQL includes data insert, query, update and delete, [[database schema|schema]] creation and modification, and data access control. Although SQL is often described as, and to a great extent is, a [[Declarative programming|declarative language]] ([[4GL]]), it also includes [[Procedural programming|procedural]] elements.\n\nSQL was one of the first commercial languages for [[Edgar F. Codd]]'s [[relational model]], as described in his influential 1970 paper, \"A Relational Model of Data for Large Shared Data Banks.\"<ref name=\"codd-relational-model\" />  Despite not entirely adhering to [[Codd's 12 rules|the relational model as described by Codd]], it became the most widely used database language.<ref name=\"SQL-Fundamentals\" /><ref name=\"IBM-sql\" />\n\nSQL became a [[Technical standard|standard]] of the [[American National Standards Institute]] (ANSI) in 1986, and of the [[International Organization for Standardization]] (ISO) in 1987.<ref name=\"ISO/IEC\" /> Since then, the standard has been revised to include a larger set of features. Despite the existence of such standards, most SQL code is not completely portable among different database systems without adjustments.\n{{toclimit|3}}\n\n== History ==\n\nSQL was initially developed at [[IBM]] by [[Donald D. Chamberlin]] and [[Raymond F. Boyce]] in the early 1970s.<ref name=\"chamberlin-boyce-sequel\" /> This version, initially called ''SEQUEL'' (''Structured English Query Language''), was designed to manipulate and retrieve data stored in IBM's original quasi-relational database management system, [[IBM System R|System R]], which a group at [[IBM Almaden Research Center|IBM San Jose Research Laboratory]] had developed during the 1970s.<ref name=\"chamberlin-boyce-sequel\" /> The acronym SEQUEL was later changed to SQL because \"SEQUEL\" was a [[trademark]] of the [[United Kingdom|UK-based]] [[Hawker Siddeley]] aircraft company.<ref name=\"oppel-databases\" />\n\nIn the late 1970s, Relational Software, Inc. (now [[Oracle Corporation]]) saw the potential of the concepts described by Codd, Chamberlin, and Boyce, and developed their own SQL-based [[RDBMS]] with aspirations of selling it to the [[United States Navy|U.S. Navy]], [[Central Intelligence Agency]], and other [[Federal government of the United States|U.S. government]] agencies. In June 1979, Relational Software, Inc. introduced the first commercially available implementation of SQL, [[Oracle Database|Oracle]] V2 (Version2) for [[VAX]] computers.\n\nAfter testing SQL at customer test sites to determine the usefulness and practicality of the system, IBM began developing commercial products based on their System R prototype including [[IBM System/38|System/38]], [[IBM SQL/DS|SQL/DS]], and [[IBM DB2|DB2]], which were commercially available in 1979, 1981, and 1983, respectively.<ref name=\"IBM-history\" />\n\n== Design ==\n\nSQL deviates in several ways from its theoretical foundation, the [[relational model]] and its [[tuple relational calculus|tuple calculus]].  In that model, a table is a [[set (mathematics)|set]] of tuples, while in SQL, tables and query results are [[list (computing)|list]]s of rows: the same row may occur multiple times, and the order of rows can be employed in queries (e.g. in the LIMIT clause).\n\nCritics argue that SQL should be replaced with a language that strictly returns to the original foundation: for example, see ''[[The Third Manifesto]]''.\n\n== Syntax ==\n{{split section|SQL syntax|date=June 2015}}\n\n=== Language elements ===\n[[File:SQL ANATOMY wiki.svg|thumb|400px|A chart showing several of the SQL language elements that compose a single statement]]\n\nThe SQL language is subdivided into several language elements, including:\n\n* ''Clauses'', which are constituent components of statements and queries. (In some cases, these are optional.)<ref name=\"ANSI/ISO/IEC\" />\n* ''Expressions'', which can produce either [[scalar (computing)|scalar]] values, or [[table (database)|tables]] consisting of [[column (database)|columns]] and [[row (database)|rows]] of data\n* ''Predicates'', which specify conditions that can be evaluated to SQL [[ternary logic|three-valued logic (3VL)]] (true/false/unknown) or [[Boolean logic|Boolean]]  [[truth value]]s and are used to limit the effects of statements and queries, or to change program flow.\n* ''Queries'', which retrieve the data based on specific criteria. This is an important element of ''SQL''.\n* ''Statements'', which may have a persistent effect on schemata and data, or may control [[Database transaction|transactions]], program flow, connections, sessions, or diagnostics.\n** SQL statements also include the [[semicolon]] (\";\") statement terminator. Though not required on every platform, it is defined as a standard part of the SQL grammar.\n* ''[[Whitespace (computer science)|Insignificant whitespace]]'' is generally ignored in SQL statements and queries, making it easier to format SQL code for readability.\n\n=== Operators ===\n\n{| class=\"wikitable\"\n|-\n! Operator\n! Description\n! Example\n|-\n| <code>=</code>\n| Equal to\n| {{code|2=sql|1= Author = 'Alcott'}}\n|-\n| <code><></code>\n| Not equal to (many DBMSs accept <code>!=</code> in addition to <code><></code>)\n| {{code|2=sql|1=Dept <> 'Sales'}}\n|-\n| <code>></code>\n| Greater than\n| {{code|2=sql|1=Hire_Date > '2012-01-31'}}\n|-\n| <code><</code>\n| Less than\n| {{code|2=sql|1=Bonus < 50000.00}}\n|-\n| <code>>=</code>\n| Greater than or equal\n| {{code|2=sql|1=Dependents >= 2}}\n|-\n| <code><=</code>\n| Less than or equal\n| {{code|2=sql|1=Rate <= 0.05}}\n|-\n| {{code|2=sql|1=BETWEEN}}\n| Between an inclusive range\n| {{code|2=sql|1=Cost BETWEEN 100.00 AND 500.00}}\n|-\n| [[Where (SQL)#LIKE|{{code|2=sql|1=LIKE}}]]\n| Match a character pattern\n| {{code|2=sql|1=First_Name LIKE 'Will%'}}\n|-\n| {{code|2=sql|1=IN}}\n| Equal to one of multiple possible values\n| {{code|2=sql|1=DeptCode IN (101, 103, 209)}}\n|-\n| {{code|2=sql|1=IS}} ''or'' {{code|2=sql|1=IS NOT}}\n| Compare to null (missing data)\n| {{code|2=sql|1=Address IS NOT NULL}}\n|-\n| {{code|2=sql|1=IS NOT DISTINCT FROM}}\n| Is equal to value or both are nulls (missing data)\n| {{code|2=sql|1=Debt IS NOT DISTINCT FROM - Receivables}}\n|-\n| {{code|2=sql|1=AS}}\n| Used to change a field name when viewing results\n| {{code|2=sql|1=SELECT employee AS 'department1'}}\n|}\n\nOther operators have at times been suggested and/or implemented, such as the [[skyline operator]] (for finding only those records that are not 'worse' than any others).\n\n{{anchor|Conditional (CASE) expressions}}\nSQL has the <code>case/when/then/else/end</code> expression, which was introduced in [[SQL-92]]. In its most general form, which is called a \"searched case\" in the SQL standard, it works like [[Conditional (programming)#Else if|else if]] in other programming languages:\n\n<source lang=\"sql\">\nCASE WHEN n > 0\n          THEN 'positive'\n     WHEN n < 0\n          THEN 'negative'\n     ELSE 'zero'\nEND\n</source>\n\nSQL tests <code>WHEN</code> conditions in the order they appear in the source. If the source does not specify an <code>ELSE</code> expression, SQL defaults to <code>ELSE NULL</code>. An abbreviated syntax\u2014called \"simple case\" in the SQL standard\u2014mirrors [[switch statement]]s:\n\n<source lang=\"sql\">\nCASE n WHEN 1\n            THEN 'one'\n       WHEN 2\n            THEN 'two'\n       ELSE 'I cannot count that high'\nEND\n</source>\n\nThis syntax uses implicit equality comparisons, with [[SQL CASE|the usual caveats for comparing with NULL]].\n\nFor the Oracle-SQL dialect, the latter can be shortened to an equivalent <code>DECODE</code> construct:\n\n<source lang=\"oracle11\">\nSELECT DECODE(n, 1, 'one',\n                 2, 'two',\n                    'i cannot count that high')\nFROM   some_table;\n</source>\n\nThe last value is the default; if none is specified, it also defaults to <code>NULL</code>.\nHowever, unlike the standard's \"simple case\", Oracle's <code>DECODE</code> considers two <code>NULL</code>s equal with each other.<ref name=\"DECODE\" />\n\n=== Queries ===\n\nThe most common operation in SQL, the query, makes use of the declarative <code>[[Select (SQL)|SELECT]]</code> statement. <code>SELECT</code> retrieves data from one or more [[Table (database)|table]]s, or expressions. Standard <code>SELECT</code> statements have no persistent effects on the database. Some non-standard implementations of <code>SELECT</code> can have persistent effects, such as the <code>SELECT INTO</code> syntax provided in some databases.<ref name=\"ms-sql-select-into\" />\n\nQueries allow the user to describe desired data, leaving the [[Database management system|database management system (DBMS)]] to carry out [[query plan|planning]], [[query optimizer|optimizing]], and performing the physical operations necessary to produce that result as it chooses.\n\nA query includes a list of columns to include in the final result, normally immediately following the <code>SELECT</code> keyword. An asterisk (\"<code>*</code>\") can be used to specify that the query should return all columns of the queried tables. <code>SELECT</code> is the most complex statement in SQL, with optional keywords and clauses that include:\n\n* The <code>[[From (SQL)|FROM]]</code> clause, which indicates the table(s) to retrieve data from. The <code>FROM</code> clause can include optional <code>[[Join (SQL)|JOIN]]</code> subclauses to specify the rules for joining tables.\n* The <code>[[Where (SQL)|WHERE]]</code> clause includes a comparison predicate, which restricts the rows returned by the query. The <code>WHERE</code> clause eliminates all rows from the result set where the comparison predicate does not evaluate to True.\n* The <code>GROUP BY</code> clause projects rows having common values into a smaller set of rows. <code>GROUP BY</code> is often used in conjunction with SQL aggregation functions or to eliminate duplicate rows from a result set. The <code>WHERE</code> clause is applied before the <code>GROUP BY</code> clause.\n* The <code>[[Having (SQL)|HAVING]]</code> clause includes a predicate used to filter rows resulting from the <code>GROUP BY</code> clause. Because it acts on the results of the <code>GROUP BY</code> clause, aggregation functions can be used in the <code>HAVING</code> clause predicate.\n* The <code>[[Order by (SQL)|ORDER BY]]</code> clause identifies which column[s] to use to sort the resulting data, and in which direction to sort them (ascending or descending). Without an <code>ORDER BY</code> clause, the order of rows returned by an SQL query is undefined.\n* The <code>DISTINCT</code> keyword<ref>\n{{cite book\n| title                 = SAS 9.4 SQL Procedure User's Guide\n| url                   = https://books.google.com/books?id=ESjMAAAAQBAJ\n| publisher             = SAS Institute\n| publication-date      = 2013\n| page                  = 248\n| isbn                  = 9781612905686\n| accessdate            = 2015-10-21\n| quote                 = Although the UNIQUE argument is identical to DISTINCT, it is not an ANSI standard.\n}}\n</ref> eliminates duplicate data.<ref>\n{{cite book\n| last1                 = Leon\n| first1                = Alexis\n| author-link1          = Alexis Leon\n| last2                 = Leon\n| first2                = Mathews\n| year              = 1999\n| chapter               = Eliminating duplicates - SELECT using DISTINCT\n| title                 = SQL: A Complete Reference\n| url                   = https://books.google.com/books?id=dmiPz2MMpfwC\n| location              = New Delhi\n| publisher             = Tata McGraw-Hill Education\n| publication-date      = 2008\n| page                  = 143\n| isbn                  = 9780074637081\n| accessdate            = 2015-10-21\n| quote                 = [...] the keyword DISTINCT [...] eliminates the duplicates from the result set.\n}}\n</ref>\n\nThe following example of a <code>SELECT</code> query returns a list of expensive books. The query retrieves all rows from the ''Book'' table in which the ''price'' column contains a value greater than 100.00. The result is sorted in ascending order by ''title''. The asterisk (*) in the ''select list'' indicates that all columns of the ''Book'' table should be included in the result set.\n\n<source lang=\"sql\">\nSELECT *\n FROM  Book\n WHERE price > 100.00\n ORDER BY title;\n</source>\n\nThe example below demonstrates a query of multiple tables, grouping, and aggregation, by returning a list of books and the number of authors associated with each book.\n\n<source lang=\"sql\">\nSELECT Book.title AS Title,\n       count(*) AS Authors\n FROM  Book\n JOIN  Book_author\n   ON  Book.isbn = Book_author.isbn\n GROUP BY Book.title;\n</source>\n\nExample output might resemble the following:\n\n Title                  Authors\n ---------------------- -------\n SQL Examples and Guide 4\n The Joy of SQL         1\n An Introduction to SQL 2\n Pitfalls of SQL        1\n\nUnder the precondition that ''isbn'' is the only common column name of the two tables and that a column named ''title'' only exists in the ''Book'' table, one could re-write the query above in the following form:\n\n<source lang=\"sql\">\nSELECT title,\n       count(*) AS Authors\n FROM  Book\n NATURAL JOIN Book_author\n GROUP BY title;\n</source>\n\nHowever, many{{quantify|date=October 2015}} vendors either do not support this approach, or require certain column-naming conventions for natural joins to work effectively.\n\nSQL includes operators and functions for calculating values on stored values. SQL allows the use of expressions in the ''select list'' to project data, as in the following example, which returns a list of books that cost more than 100.00 with an additional ''sales_tax'' column containing a sales tax figure calculated at 6% of the ''price''.\n\n<source lang=\"sql\">\nSELECT isbn,\n       title,\n       price,\n       price * 0.06 AS sales_tax\n FROM  Book\n WHERE price > 100.00\n ORDER BY title;\n</source>\n\n==== Subqueries ====\n\nQueries can be nested so that the results of one query can be used in another query via a relational operator or aggregation function. A nested query is also known as a ''subquery''. While joins and other table operations provide computationally superior (i.e. faster) alternatives in many cases, the use of subqueries introduces a hierarchy in execution that can be useful or necessary. In the following example, the aggregation function <code>AVG</code> receives as input the result of a subquery:\n\n<source lang=\"sql\">\nSELECT isbn,\n       title,\n       price\n FROM  Book\n WHERE price < (SELECT AVG(price) FROM Book)\n ORDER BY title;\n</source>\n\nA subquery can use values from the outer query, in which case it is known as a [[correlated subquery]].\n\nSince 1999 the SQL standard allows named subqueries called [[common table expression]]s (named and designed after the IBM DB2 version 2 implementation; Oracle calls these [[subquery factoring]]). CTEs can also be [[recursive]] by referring to themselves; [[Hierarchical and recursive queries in SQL|the resulting mechanism]] allows tree or graph traversals (when represented as relations), and more generally [[fixpoint]] computations.\n\n==== Inline view ====\n\nAn Inline view is the use of referencing an SQL subquery in a FROM clause.  Essentially, the inline view is a subquery that can be selected from or joined to.  Inline View functionality allows the user to reference the subquery as a table.  The inline view also is referred to as a ''derived table'' or a ''subselect''.  Inline view functionality was introduced in Oracle 9i.<ref name=\"Inline View/Derived Table\" />\n\nIn the following example, the SQL statement involves a join from the initial Books table to the Inline view \"Sales\".  This inline view captures associated book sales information using the ISBN to join to the Books table.  As a result, the inline view provides the result set with additional columns (the number of items sold and the company that sold the books):\n\n<source lang=\"sql\">\nSELECT b.isbn, b.title, b.price, sales.items_sold, sales.company_nm\nFROM Book b\n  JOIN (SELECT SUM(Items_Sold) Items_Sold, Company_Nm, ISBN\n        FROM Book_Sales\n        GROUP BY Company_Nm, ISBN) sales\n  ON sales.isbn = b.isbn\n</source>\n\n==== Null or three-valued logic (3VL) ====\n{{main article|Null (SQL)}}\n\nThe concept of [[Null (SQL)|Null]] was introduced{{by whom|date=October 2015}} into SQL to handle missing information in the relational model. The word <code>NULL</code> is a reserved keyword in SQL, used to identify the Null special marker. Comparisons with Null, for instance equality (=) in WHERE clauses, results in an Unknown truth value. In SELECT statements SQL returns only results for which the WHERE clause returns a value of True; i.e., it excludes results with values of False and also excludes those whose value is Unknown.\n\nAlong with True and False, the Unknown resulting from direct comparisons with Null thus brings a fragment of [[three-valued logic]] to SQL. The truth tables SQL uses for AND, OR, and NOT correspond to a common fragment of the Kleene and Lukasiewicz three-valued logic (which differ in their definition of implication, however SQL defines no such operation).<ref name=\"Klein\" />\n\n{| border=\"0\"\n|-\n| valign=\"top\" |\n{| class=\"wikitable\"\n|-\n! colspan=2 rowspan=2 | p AND q\n! colspan=3 | p\n|-\n! style=\"width: 5em;\" | True\n! style=\"width: 5em;\" | False\n! style=\"width: 5em;\" | Unknown\n|-\n! rowspan=3 style=\"width: 1.2em;\" | q || style=\"width: 5em;\" | True\n| {{yes|True}}\n| {{no|False}}\n| {{Unknown}}\n|-\n! style=\"width: 5em;\" | False\n| {{no|False}}\n| {{no|False}}\n| {{no|False}}\n|-\n! style=\"width: 5em;\" | Unknown\n| {{Unknown}}\n| {{no|False}}\n| {{Unknown}}\n|}\n| valign=\"top\" |\n{| class=\"wikitable\"\n|-\n! colspan=2 rowspan=2 | p OR q\n! colspan=3 | p\n|-\n! style=\"width: 5em;\" | True\n! style=\"width: 5em;\" | False\n! style=\"width: 5em;\" | Unknown\n|-\n! rowspan=3 style=\"width: 1.2em;\" | q || style=\"width: 5em;\" | True\n| {{yes|True}}\n| {{yes|True}}\n| {{yes|True}}\n|-\n! style=\"width: 5em;\" | False\n| {{yes|True}}\n| {{no|False}}\n| {{Unknown}}\n|-\n! style=\"width: 5em;\" | Unknown\n| {{yes|True}}\n| {{Unknown}}\n| {{Unknown}}\n|}\n|}\n\n{| border=\"0\"\n|-\n| valign=\"top\" |\n{| class=\"wikitable\"\n|-\n! colspan=2 rowspan=2 | p = q\n! colspan=3 | p\n|-\n! style=\"width: 5em;\" | True\n! style=\"width: 5em;\" | False\n! style=\"width: 5em;\" | Unknown\n|-\n! rowspan=3 style=\"width: 1.2em;\" | q || style=\"width: 5em;\" | True\n| {{yes|True}}\n| {{no|False}}\n| {{Unknown}}\n|-\n! style=\"width: 5em;\" | False\n| {{no|False}}\n| {{yes|True}}\n| {{Unknown}}\n|-\n! style=\"width: 5em;\" | Unknown\n| {{Unknown}}\n| {{Unknown}}\n| {{Unknown}}\n|}\n| valign=\"top\" |\n{| class=\"wikitable\"\n|-\n! style=\"width: 5em;\" | q\n! style=\"width: 5em;\" | NOT q\n|-\n! True\n| {{no|False}}\n|-\n! False\n| {{yes|True}}\n|-\n! Unknown\n| {{Unknown}}\n|}\n|}\n\nThere are however disputes about the semantic interpretation of Nulls in SQL because of its treatment outside direct comparisons. As seen in the table above, direct equality comparisons between two NULLs in SQL (e.g. <code>NULL = NULL</code>) return a truth value of Unknown. This is in line with the interpretation that Null does not have a value (and is not a member of any data domain) but is rather a placeholder or \"mark\" for missing information. However, the principle that two Nulls aren't equal to each other is effectively violated in the SQL specification for the <code>UNION</code> and <code>INTERSECT</code> operators, which do identify nulls with each other.<ref name=\"Meyden\" /> Consequently, these [[Set operations (SQL)|set operations in SQL]] may produce results not representing sure information, unlike operations involving explicit comparisons with NULL (e.g. those in a <code>WHERE</code> clause discussed above). In Codd's 1979 proposal (which was basically adopted by SQL92) this semantic inconsistency is rationalized by arguing that removal of duplicates in set operations happens \"at a lower level of detail than equality testing in the evaluation of retrieval operations\".<ref name=\"Klein\" /> However, computer-science professor Ron van der Meyden concluded that \"The inconsistencies in the SQL standard mean that it is not possible to ascribe any intuitive logical semantics to the treatment of nulls in SQL.\"<ref name=\"Meyden\" />\n\nAdditionally, because SQL operators return Unknown when comparing anything with Null directly, SQL provides two Null-specific comparison predicates: <code>IS NULL</code> and <code>IS NOT NULL</code> test whether data is or is not Null.<ref name=\"SQL2003-Part2-Sec87\" /> SQL does not explicitly support [[universal quantification]], and must work it out as a negated [[existential quantification]].<ref name=\"Negri\" /><ref name=\"Fratarcangeli\" /><ref name=\"kawash\" /> There is also the \"<row value expression> IS DISTINCT FROM <row value expression>\" infixed comparison operator, which returns TRUE unless both operands are equal or both are NULL. Likewise, IS NOT DISTINCT FROM is defined as \"NOT (<row value expression> IS DISTINCT FROM <row value expression>)\". [[SQL:1999]] also introduced <code>BOOLEAN</code> type variables, which according to the standard can also hold Unknown values. In practice, a number of systems (e.g. [[PostgreSQL]]) implement the BOOLEAN Unknown as a BOOLEAN NULL.\n\n=== Data manipulation ===\n\nThe [[Data Manipulation Language]] (DML) is the subset of SQL used to add, update and delete data:\n* <code>[[Insert (SQL)|INSERT]]</code> adds rows (formally [[tuple]]s) to an existing table, e.g.:\n\n<source lang=\"sql\">\nINSERT INTO example\n (field1, field2, field3)\n VALUES\n ('test', 'N', NULL);\n</source>\n\n* <code>[[Update (SQL)|UPDATE]]</code> modifies a set of existing table rows, e.g.:\n\n<source lang=\"sql\">\nUPDATE example\n SET field1 = 'updated value'\n WHERE field2 = 'N';\n</source>\n\n* <code>[[Delete (SQL)|DELETE]]</code> removes existing rows from a table, e.g.:\n\n<source lang=\"sql\">\nDELETE FROM example\n WHERE field2 = 'N';\n</source>\n\n* <code>[[Merge (SQL)|MERGE]]</code> is used to combine the data of multiple tables. It combines the <code>INSERT</code> and <code>UPDATE</code> elements. It is defined in the SQL:2003 standard; prior to that, some databases provided similar functionality via different syntax, sometimes called \"[[upsert]]\".\n\n<source lang=\"sql\">\n MERGE INTO table_name USING table_reference ON (condition)\n WHEN MATCHED THEN\n UPDATE SET column1 = value1 [, column2 = value2 ...]\n WHEN NOT MATCHED THEN\n INSERT (column1 [, column2 ...]) VALUES (value1 [, value2 ...])\n</source>\n\n=== Transaction controls ===\n\nTransactions, if available, wrap DML operations:\n\n* <code>START TRANSACTION</code> (or <code>BEGIN WORK</code>, or <code>BEGIN TRANSACTION</code>, depending on SQL dialect) marks the start of a [[database transaction]], which either completes entirely or not at all.\n* <code>SAVE TRANSACTION</code> (or <code>SAVEPOINT</code>) saves the state of the database at the current point in transaction\n\n<source lang=\"sql\">\nCREATE TABLE tbl_1(id int);\n INSERT INTO tbl_1(id) VALUES(1);\n INSERT INTO tbl_1(id) VALUES(2);\nCOMMIT;\n UPDATE tbl_1 SET id=200 WHERE id=1;\nSAVEPOINT id_1upd;\n UPDATE tbl_1 SET id=1000 WHERE id=2;\nROLLBACK to id_1upd;\n SELECT id from tbl_1;\n</source>\n\n* <code>[[Commit (SQL)|COMMIT]]</code> makes all data changes in a transaction permanent.\n* <code>[[Rollback (SQL)|ROLLBACK]]</code> discards all data changes since the last <code>COMMIT</code> or <code>ROLLBACK</code>, leaving the data as it was prior to those changes. Once the <code>COMMIT</code> statement completes, the transaction's changes cannot be rolled back.\n\n<code>COMMIT</code> and <code>ROLLBACK</code> terminate the current transaction and release data locks. In the absence of a <code>START TRANSACTION</code> or similar statement, the semantics of SQL are implementation-dependent.\nThe following example shows a classic transfer of funds transaction, where money is removed from one account and added to another. If either the removal or the addition fails, the entire transaction is rolled back.\n\n<source lang=\"sql\">\nSTART TRANSACTION;\n UPDATE Account SET amount=amount-200 WHERE account_number=1234;\n UPDATE Account SET amount=amount+200 WHERE account_number=2345;\n\nIF ERRORS=0 COMMIT;\nIF ERRORS<>0 ROLLBACK;\n</source>\n\n=== Data definition ===\n\nThe [[Data Definition Language]] (DDL) manages table and index structure. The most basic items of DDL are the <code>CREATE</code>, <code>ALTER</code>, <code>RENAME</code>, <code>DROP</code> and <code>TRUNCATE</code> statements:\n\n* <code>[[Create (SQL)|CREATE]]</code> creates an object (a table, for example) in the database, e.g.:\n\n<source lang=\"sql\">\nCREATE TABLE example(\n column1 INTEGER,\n column2 VARCHAR(50),\n column3 DATE NOT NULL,\n PRIMARY KEY (column1, column2)\n);\n</source>\n\n* <code>[[Alter (SQL)|ALTER]]</code> modifies the structure of an existing object in various ways, for example, adding a column to an existing table or a constraint, e.g.:\n\n<source lang=\"sql\">\nALTER TABLE example ADD column4 NUMBER(3) NOT NULL;\n</source>\n\n* <code>[[Truncate (SQL)|TRUNCATE]]</code> deletes all data from a table in a very fast way, deleting the data inside the table and not the table itself. It usually implies a subsequent COMMIT operation, i.e., it cannot be rolled back (data is not written to the logs for rollback later, unlike DELETE).\n\n<source lang=\"sql\">\nTRUNCATE TABLE example;\n</source>\n\n* <code>[[Drop (SQL)|DROP]]</code> deletes an object in the database, usually irretrievably, i.e., it cannot be rolled back, e.g.:\n\n<source lang=\"sql\">\nDROP TABLE example;\n</source>\n\n=== Data types ===\n\nEach column in an SQL table declares the type(s) that column may contain. ANSI SQL includes the following data types.<ref name=\"SQL1992\" />\n\n; Character strings\n* <code>CHARACTER(<var>n</var>)</code> or <code>CHAR(<var>n</var>)</code>: fixed-width <var>n</var>-character string, padded with spaces as needed\n* <code>CHARACTER VARYING(<var>n</var>)</code> or <code>VARCHAR(<var>n</var>)</code>: variable-width string with a maximum size of <var>n</var> characters\n* <code>NATIONAL CHARACTER(<var>n</var>)</code> or <code>NCHAR(<var>n</var>)</code>: fixed width string supporting an international character set\n* <code>NATIONAL CHARACTER VARYING(<var>n</var>)</code> or <code>NVARCHAR(<var>n</var>)</code>: variable-width <code>NCHAR</code> string\n; Bit strings\n* <code>BIT(<var>n</var>)</code>: an array of <var>n</var> bits\n* <code>BIT VARYING(<var>n</var>)</code>: an array of up to <var>n</var> bits\n; Numbers\n* <code>INTEGER</code>, <code>SMALLINT</code> and <code>BIGINT</code>\n* <code>FLOAT</code>, <code>REAL</code> and <code>DOUBLE PRECISION</code>\n* <code>NUMERIC(<var>precision</var>, <var>scale</var>)</code> or <code>DECIMAL(<var>precision</var>, <var>scale</var>)</code>\n\nFor example, the number 123.45 has a precision of 5 and a scale of 2. The <var>precision</var> is a positive integer that determines the number of significant digits in a particular radix (binary or decimal). The <var>scale</var> is a non-negative integer. A scale of 0 indicates that the number is an integer. For a decimal number with scale S, the exact numeric value is the integer value of the significant digits divided by 10<sup>S</sup>.\n\nSQL provides a function to round numerics or dates, called <code>TRUNC</code> (in Informix, DB2, PostgreSQL, Oracle and MySQL) or <code>ROUND</code> (in Informix, SQLite, Sybase, Oracle, PostgreSQL and Microsoft SQL Server)<ref name=\"Jones 127\" />\n\n; Temporal (date/time)\n* <code>DATE</code>: for date values (e.g. <code>2011-05-03</code>)\n* <code>TIME</code>: for time values (e.g. <code>15:51:36</code>). The granularity of the time value is usually a ''tick'' (100 nanoseconds).\n* <code>TIME WITH TIME ZONE</code> or <code>TIMETZ</code>: the same as <code>TIME</code>, but including details about the time zone in question.\n* <code>TIMESTAMP</code>: This is a <code>DATE</code> and a <code>TIME</code> put together in one variable (e.g. <code>2011-05-03 15:51:36</code>).\n* <code>TIMESTAMP WITH TIME ZONE</code> or <code>TIMESTAMPTZ</code>: the same as <code>TIMESTAMP</code>, but including details about the time zone in question.\n\nSQL provides several functions for generating a date / time variable out of a date / time string (<code>TO_DATE</code>, <code>TO_TIME</code>, <code>TO_TIMESTAMP</code>), as well as for extracting the respective members (seconds, for instance) of such variables. The current system date / time of the database server can be called by using functions like <code>NOW</code>.\nThe [[IBM Informix]] implementation provides the <code>EXTEND</code> and the <code>FRACTION</code> functions to increase the accuracy of time, for systems requiring sub-second precision.<ref name=\"sqlr150\" />\n\n=== Data control ===\n\nThe [[Data Control Language]] (DCL) authorizes users to access and manipulate data.\nIts two main statements are:\n\n* <code>GRANT</code> authorizes one or more users to perform an operation or a set of operations on an object.\n* <code>REVOKE</code> eliminates a grant, which may be the default grant.\n\nExample:\n\n<source lang=\"sql\">\nGRANT SELECT, UPDATE\n ON example\n TO some_user, another_user;\n\nREVOKE SELECT, UPDATE\n ON example\n FROM some_user, another_user;\n</source>\n\n== Procedural extensions ==\n\nSQL is designed for a specific purpose: to query [[data]] contained in a [[relational database]]. SQL is a [[Set (computer science)|set]]-based, [[declarative programming language]], not an [[imperative programming language]] like [[C (programming language)|C]] or [[BASIC programming language|BASIC]]. However, extensions to Standard SQL add [[procedural programming language]] functionality, such as control-of-flow constructs. These include:\n\n{| class=\"wikitable\"\n|-\n! Source\n! Common name\n! Full name\n|-\n| ANSI/ISO Standard\n| [[SQL/PSM]]\n| SQL/Persistent Stored Modules\n|-\n| [[Interbase]] / [[Firebird (database server)|Firebird]]\n| [[Procedural SQL|PSQL]]\n| Procedural SQL\n|-\n| [[IBM DB2]]\n| [[SQL PL]]\n| SQL Procedural Language (implements SQL/PSM)\n|-\n| [[IBM Informix]]\n| [[Stored Procedural Language|SPL]]\n| Stored Procedural Language\n|-\n| IBM [[Netezza]]\n| NZPLSQL [http://pic.dhe.ibm.com/infocenter/ntz/v7r0m3/index.jsp?topic=%2Fcom.ibm.nz.sproc.doc%2Fc_sproc_stored_procs.html]\n| (based on Postgres PL/pgSQL)\n|-\n| [[Microsoft]] / [[Sybase]]\n| [[Transact-SQL|T-SQL]]\n| Transact-SQL\n|-\n| [[Mimer SQL]]\n| [[SQL/PSM]]\n| SQL/Persistent Stored Module (implements SQL/PSM)\n|-\n| [[MySQL]]\n| [[SQL/PSM]]\n| SQL/Persistent Stored Module (implements SQL/PSM)\n|-\n| [[MonetDB]]\n| [[SQL/PSM]]\n| SQL/Persistent Stored Module (implements SQL/PSM)\n|-\n| [[NuoDB]]\n| SSP\n| Starkey Stored Procedures\n|-\n| [[Oracle Database|Oracle]]\n| [[PL/SQL]]\n| Procedural Language/SQL (based on [[Ada (programming language)|Ada]])\n|-\n| [[PostgreSQL]]\n| [[PL/pgSQL]]\n| Procedural Language/PostgreSQL Structured Query Language (implements SQL/PSM)\n|-\n| [[Sybase]]\n| [[Watcom-SQL]]\n| SQL Anywhere Watcom-SQL Dialect\n|-\n| [[Teradata]]\n| SPL\n| Stored Procedural Language\n|-\n| [[SAP SE|SAP]]\n| [[SAP HANA]]\n| SQL Script\n|}\n\nIn addition to the standard SQL/PSM extensions and proprietary SQL extensions, procedural and [[object-oriented programming language|object-oriented]] programmability is available on many SQL platforms via DBMS integration with other languages. The SQL standard defines [[SQL/JRT]] extensions (SQL Routines and Types for the Java Programming Language) to support [[Java (programming language)|Java]] code in SQL databases. [[SQL Server 2005]] uses the [[SQLCLR]] (SQL Server Common Language Runtime) to host managed [[Microsoft .NET|.NET]] assemblies in the database, while prior versions of SQL Server were restricted to unmanaged extended stored procedures primarily written in C. PostgreSQL lets users write functions in a wide variety of languages\u2014including [[Perl]], [[Python (programming language)|Python]], [[Tcl]], and C.<ref name=\"PostgreSQL server programming\" />\n\n== Interoperability and standardization ==\n\nSQL implementations are incompatible between vendors and do not necessarily completely follow standards. In particular date and time syntax, string concatenation, <code>NULL</code>s, and comparison [[case sensitivity]] vary from vendor to vendor. A particular exception is [[PostgreSQL]], which strives for standards compliance.<ref name=\"About PostgreSQL\" />\n\nPopular implementations of SQL commonly omit support for basic features of Standard SQL, such as the <code>DATE</code> or <code>TIME</code> data types.  The most obvious such examples, and incidentally the most popular commercial and proprietary SQL DBMSs, are Oracle (whose <code>DATE</code> behaves as <code>DATETIME</code>,<ref name=\"Ora DATE\" /><ref name=\"Ora DATETIME\" /> and lacks a <code>TIME</code> type)<ref name=\"Ora TIME\" /> and MS SQL Server (before the 2008 version). As a result, SQL code can rarely be ported between database systems without modifications.\n\nThere are several reasons for this lack of portability between database systems:\n\n* The complexity and size of the SQL standard means that most implementors do not support the entire standard.\n* The standard does not specify database behavior in several important areas (e.g. [[index (database)|indexes]], file storage...), leaving implementations to decide how to behave.\n* The SQL standard precisely specifies the syntax that a conforming database system must implement. However, the standard's specification of the semantics of language constructs is less well-defined, leading to ambiguity.\n* Many database vendors have large existing customer bases; where the newer version of the SQL standard conflicts with the prior behavior of the vendor's database, the vendor may be unwilling to break [[backward compatibility]].\n* There is little commercial incentive for vendors to make it easier for users to change database suppliers (see [[vendor lock-in]]).\n* Users evaluating database software tend to place other factors such as performance higher in their priorities than standards conformance.\n\nSQL was adopted as a standard by the [[American National Standards Institute]] (ANSI) in 1986 as SQL-86<ref name=\"X3H2\" /> and the [[International Organization for Standardization]] (ISO) in 1987. Nowadays the standard is subject to continuous improvement by the Joint Technical Committee ''ISO/IEC JTC 1, Information technology, Subcommittee SC 32, Data management and interchange'', which affiliate to [[International Organization for Standardization|ISO]] as well as [[International Electrotechnical Commission|IEC]]. It is commonly denoted by the pattern: ''ISO/IEC 9075-n:yyyy Part n: title'', or, as a shortcut, ''ISO/IEC 9075''.\n\n''ISO/IEC 9075'' is complemented by ''ISO/IEC 13249: SQL Multimedia and Application Packages'' ([[SQL/MM]]), which defines SQL based interfaces and packages to widely spread applications like video, audio and [[Georeference|spatial data]].\n\nUntil 1996, the [[National Institute of Standards and Technology]] (NIST) data management standards program certified SQL DBMS compliance with the SQL standard. Vendors now self-certify the compliance of their products.<ref name=\"Doll\" />\n\nThe original standard declared that the official pronunciation for \"SQL\" was an [[initialism]]: {{IPAc-en|\u02c8|\u025b|s|_|k|ju\u02d0|_|\u02c8|\u025b|l}} (\"es queue el\").<ref name=\"SQL-Fundamentals\" /> Regardless, many English-speaking database professionals (including [[Donald Chamberlin]] himself<ref name=\"Gillespie\" />) use the [[acronym]]-like pronunciation of {{IPAc-en|\u02c8|s|i\u02d0|k|w|\u0259|l}} (\"sequel\"),<ref name=\"Melton\" /> mirroring the language's pre-release development name of \"SEQUEL\".<ref name=chamberlin-boyce-sequel /><ref name=oppel-databases />\n\nThe SQL standard has gone through a number of revisions:\n\n{| class=wikitable\n|-\n! Year\n! Name\n! Alias\n! Comments\n|-\n| 1986\n| SQL-86\n| SQL-87\n| First formalized by ANSI.\n|-\n| 1989\n| SQL-89\n| [[Federal Information Processing Standard|FIPS]] 127-1\n| Minor revision that added integrity constraints, adopted as FIPS 127-1.\n|-\n| 1992\n| [[SQL-92]]\n| SQL2, FIPS 127-2\n| Major revision (ISO 9075), ''Entry Level'' SQL-92 adopted as FIPS 127-2.\n|-\n| 1999\n| [[SQL:1999]]\n| SQL3\n| Added regular expression matching, [[hierarchical and recursive queries in SQL|recursive queries]] (e.g. [[transitive closure]]), [[Database trigger|triggers]], support for procedural and control-of-flow statements, non-scalar types, and some object-oriented features (e.g. [[structured type]]s). Support for embedding SQL in Java ([[SQL/OLB]]) and vice versa ([[SQL/JRT]]).\n|-\n| 2003\n| [[SQL:2003]]\n| SQL 2003\n| Introduced [[XML]]-related features ([[SQL/XML]]), ''window functions'', standardized sequences, and columns with auto-generated values (including identity-columns).\n|-\n| 2006\n| [[SQL:2006]]\n| SQL 2006\n| ISO/IEC 9075-14:2006 defines ways that SQL can be used with XML. It defines ways of importing and storing XML data in an SQL database, manipulating it within the database, and publishing both XML and conventional SQL-data in XML form. In addition, it lets applications integrate queries into their SQL code with [[XQuery]], the XML Query Language published by the World Wide Web Consortium ([[W3C]]), to concurrently access ordinary SQL-data and XML documents.<ref name=\"SQLXML2006\" />\n|-\n| 2008\n| [[SQL:2008]]\n| SQL 2008\n| Legalizes ORDER BY outside cursor definitions. Adds INSTEAD OF triggers.  Adds the TRUNCATE statement.<ref name=\"iablog.sybase.com-paulley\" />\n|-\n| 2011\n| [[SQL:2011]]\n|\n| \n|}\n\nInterested parties may purchase SQL standards documents from ISO,<ref name=\"ISO/IEC 9075-2:2011\" /> IEC or ANSI. A draft of SQL:2008 is freely available as a [[ZIP (file format)|zip]] archive.<ref name=\"Whitemarsh\" />\n\nThe SQL standard is divided into nine parts.\n\n* ISO/IEC 9075-1:2011 Part 1: ''Framework'' (SQL/Framework). It provides logical concepts.\n* ISO/IEC 9075-2:2011 Part 2: ''Foundation'' (SQL/Foundation). It contains the most central elements of the language and consists of both ''mandatory and optional'' features.\n* ISO/IEC 9075-3:2008 Part 3: ''Call-Level Interface'' ([[SQL/CLI]]). It defines interfacing components (structures, procedures, variable bindings) that can be used to execute SQL statements from applications written in Ada, C respectively C++, COBOL, Fortran, MUMPS, Pascal or PL/I. (For Java see part 10.) SQL/CLI is defined in such a way that SQL statements and SQL/CLI procedure calls are treated as separate from the calling application's source code. [[Open Database Connectivity]] is a well-known superset of SQL/CLI. This part of the standard consists solely of ''mandatory'' features.\n* ISO/IEC 9075-4:2011 Part 4: ''Persistent Stored Modules'' ([[SQL/PSM]]) It standardizes procedural extensions for SQL, including flow of control, condition handling, statement condition signals and resignals, cursors and local variables, and assignment of expressions to variables and parameters. In addition, SQL/PSM formalizes declaration and maintenance of persistent database language routines (e.g., \"stored procedures\"). This part of the standard consists solely of ''optional'' features.\n* ISO/IEC 9075-9:2008 Part 9: ''Management of External Data'' ([[SQL/MED]]). It provides extensions to SQL that define foreign-data wrappers and datalink types to allow SQL to manage external data. External data is data that is accessible to, but not managed by, an SQL-based DBMS. This part of the standard consists solely of ''optional'' features.\n* ISO/IEC 9075-10:2008 Part 10: ''Object Language Bindings'' ([[SQL/OLB]]). It defines the syntax and semantics of [[SQLJ]], which is SQL embedded in Java (see also part 3). The standard also describes mechanisms to ensure binary portability of SQLJ applications, and specifies various Java packages and their contained classes. This part of the standard consists solely of optional features, as opposed to SQL/OLB [[JDBC]], which is not part of the SQL standard, which defines an [[API]].{{citation needed|date=February 2013}}\n* ISO/IEC 9075-11:2011 Part 11: ''Information and Definition Schemas'' ([[SQL/Schemata]]). It defines the Information Schema and Definition Schema, providing a common set of tools to make SQL databases and objects self-describing. These tools include the SQL object identifier, structure and integrity constraints, security and authorization specifications, features and packages of ISO/IEC 9075, support of features provided by SQL-based DBMS implementations, SQL-based DBMS implementation information and sizing items, and the values supported by the DBMS implementations.<ref name=\"ISO/IEC 9075-11:2008\" /> This part of the standard contains both ''mandatory and optional'' features.\n* ISO/IEC 9075-13:2008 Part 13: ''SQL Routines and Types Using the Java Programming Language'' ([[SQL/JRT]]). It specifies the ability to invoke static Java methods as routines from within SQL applications ('Java-in-the-database'). It also calls for the ability to use Java classes as SQL structured user-defined types. This part of the standard consists solely of ''optional'' features.\n* ISO/IEC 9075-14:2011 Part 14: ''XML-Related Specifications'' ([[SQL/XML]]). It specifies SQL-based extensions for using XML in conjunction with SQL. The ''XML'' data type is introduced, as well as several routines, functions, and XML-to-SQL data type mappings to support manipulation and storage of XML in an SQL database.<ref name=\"SQLXML2006\" /> This part of the standard consists solely of ''optional'' features.{{Citation needed|date=July 2012}}\n\nISO/IEC 9075 is complemented by ISO/IEC 13249 ''SQL Multimedia and Application Packages''. This closely related but separate standard is developed by the same committee. It defines interfaces and packages  based on SQL. The aim is a unified access to typical database applications like text, pictures, data mining or [[Georeference|spatial data]].\n\n* ISO/IEC 13249-1:2007 Part 1: ''Framework''\n* ISO/IEC 13249-2:2003 Part 2: ''Full-Text''\n* ISO/IEC 13249-3:2011 Part 3: ''Spatial''\n* ISO/IEC 13249-5:2003 Part 5: ''Still image''\n* ISO/IEC 13249-6:2006 Part 6: ''Data mining''\n* ISO/IEC 13249-8:xxxx Part 8: ''Metadata registries (MDR)'' (work in progress)\n\n== Alternatives ==\n\nA distinction should be made between alternatives to SQL as a language, and alternatives to the relational model itself.  Below are proposed relational alternatives to the SQL language.  See [[navigational database]] and [[NoSQL]] for alternatives to the relational model.\n\n* [[.QL]]: object-oriented Datalog\n* [[4th Dimension (Software)|4D Query Language]] (4D QL)\n* [http://tech.pro/blog/1917/a-better-query-language-bql-language-specification BQL]: a superset that compiles down to SQL\n* [[Datalog]]: critics suggest that [[Datalog]] has two advantages over SQL: it has cleaner semantics, which facilitates program understanding and maintenance, and it is more expressive, in particular for recursive queries.<ref name=\"PROLE\" />\n* [[HTSQL]]: URL based query method\n* [[IBM Business System 12]] (IBM BS12): one of the first fully relational database management systems, introduced in 1982\n* [[ISBL]]\n* [[Java Object Oriented Querying|jOOQ]]: SQL implemented in Java as an [[Domain-specific language|internal domain-specific language]]\n* [[Java Persistence Query Language]] (JPQL): The query language used by the Java Persistence API and [[Hibernate (Java)|Hibernate]] persistence library\n* [[Language Integrated Query|LINQ]]: Runs SQL statements written like language constructs to query collections directly from inside [[.NET Framework|.Net]] code.\n* [[Object Query Language]]\n* QBE ([[Query By Example]]) created by Mosh\u00e8 Zloof, IBM 1977\n* [[QUEL query languages|Quel]] introduced in 1974 by the U.C. Berkeley Ingres project.\n* [[Tutorial D]]\n* [[XQuery]]\n\n==Distributed SQL processing==\n\n[[DRDA|Distributed Relational Database Architecture]] (DRDA) was designed by a work group within IBM in the period 1988 to 1994. DRDA enables network connected relational databases to cooperate to fulfill SQL requests.<ref>{{cite journal|last1=Reinsch, R.|title=Distributed database for SAA|journal=IBM Systems Journal|date=1988|volume=27|issue=3|pages=362\u2013389|doi=10.1147/sj.273.0362}}</ref><ref>{{cite book|title=Distributed Relational Database Architecture Reference|date=1990|publisher=IBM Corp. SC26-4651-0}}</ref>\n\nAn interactive user or program can issue SQL statements to a local RDB and receive tables of data and status indicators in reply from remote RDBs. SQL statements can also be compiled and stored in remote RDBs as packages and then invoked by package name. This is important for the efficient operation of application programs that issue complex, high-frequency queries. It is especially important when the tables to be accessed are located in remote systems.\n\nThe messages, protocols, and structural components of DRDA are defined by the [[Distributed Data Management Architecture]].\n\n== See also ==\n{{Wikipedia books|SQL}}\n\n* [[Comparison of object-relational database management systems]]\n* [[Comparison of relational database management systems]]\n* [[D (data language specification)]]\n* [[D4 (programming language)]]\n* [[Hierarchical model]]\n* [[List of relational database management systems]]\n* [[MUMPS]]\n* [[NoSQL]]\n* [[Transact-SQL]]\n* [[Online analytical processing]] (OLAP)\n* [[Online transaction processing]] (OLTP)\n* [[Data warehouse]]\n* [[relational data stream management system]]\n* [[Star schema]]\n* [[Snowflake schema]]\n* [[DB2 SQL return codes]]\n\n== Notes ==\n\n{{reflist|30em|refs=\n<ref name=\"ars\">{{ cite web | last = Paul | first = Ryan | title = A guided tour of the Microsoft Command Shell | url = http://arstechnica.com/business/news/2005/10/msh.ars/4 | publisher = Ars Technica | accessdate = 10 April 2011 }}</ref>\n<ref name=\"iana\">{{ cite web | url = http://www.iana.org/assignments/media-types/application/sql | title = Media Type registration for application/sql | publisher = [[Internet Assigned Numbers Authority]] | date = 10 April 2013 | accessdate = 10 April 2013 }}</ref>\n<ref name=\"application/sql\">{{ cite web | url = http://tools.ietf.org/html/rfc6922 | title = The application/sql Media Type, RFC 6922 | page = 3 | publisher = [[Internet Engineering Task Force]] | date = April 2013 | accessdate = 10 April 2013 }}</ref>\n<ref name=\"learningSQL\">{{ cite book | last = Beaulieu | first = Alan | title = Learning SQL | editor = Mary E Treseler | publisher = O'Reilly | location = Sebastapol, CA, USA | date = April 2009 | edition = 2nd | isbn = 978-0-596-52083-0 }}</ref>\n<ref name=\"oed\">{{ cite web | title = SQL, n. | website = Oxford English Dictionary | publisher = Oxford University Press | accessdate = 2014-11-27 | url = http://www.oed.com/view/Entry/260112?redirectedFrom=SQL#eid }}</ref>\n<ref name=\"Britannica\">{{ cite web | author = Encyclopedia Britannica | title = SQL | url = http://www.britannica.com/EBchecked/topic/569684/SQL | accessdate = 2013-04-02 }}</ref>\n<ref name=\"oed-US\">{{ cite web | author = Oxford Dictionaries | title = SQL | url = http://oxforddictionaries.com/definition/american_english/SQL }}\n</ref>\n<ref name=\"IBM-SQL\">{{ cite web | author = IBM | title = SQL Guide | url = http://publib.boulder.ibm.com/infocenter/soliddb/v6r3/topic/com.ibm.swg.im.soliddb.sql.doc/doc/tables.rows.and.columns.html }}</ref>\n<ref name=\"MS-SQL-def\">{{ cite web | author = Microsoft | title = Structured Query Language (SQL) | url = http://msdn.microsoft.com/en-gb/library/windows/desktop/ms714670(v=vs.85).aspx }}</ref>\n<ref name=\"codd-relational-model\">{{ cite journal | last = Codd | first = Edgar F | title = A Relational Model of Data for Large Shared Data Banks | journal = Communications of the ACM | volume = 13 | issue = 6 | pages = 377\u201387 | publisher = Association for Computing Machinery | date = June 1970 | url = http://www.acm.org/classics/nov95/toc.html | accessdate = 2007-06-09 | doi = 10.1145/362384.362685 }}</ref>\n<ref name=\"SQL-Fundamentals\">{{ cite web | last = Chapple | first = Mike | title = SQL Fundamentals | work = Databases | publisher = About.com | url = http://databases.about.com/od/sql/a/sqlfundamentals.htm | accessdate = 2009-01-28 }}</ref>\n<ref name=\"IBM-sql\">{{ cite web | title = Structured Query Language (SQL) | publisher = International Business Machines | url = http://publib.boulder.ibm.com/infocenter/db2luw/v9/index.jsp?topic=com.ibm.db2.udb.admin.doc/doc/c0004100.htm | date = October 27, 2006 | accessdate = 2007-06-10 }}</ref>\n<ref name=\"ISO/IEC\">{{ cite web | url = http://www.iso.org/iso/catalogue_detail.htm?csnumber=45498 | title = ISO/IEC 9075-1:2008: Information technology&nbsp;\u2013 Database languages&nbsp;\u2013 SQL&nbsp;\u2013 Part 1: Framework (SQL/Framework) }}</ref>\n<ref name=\"chamberlin-boyce-sequel\">{{ cite journal | last1 = Chamberlin | first1 = Donald D | last2 = Boyce | first2 = Raymond F | title = SEQUEL: A Structured English Query Language | journal = Proceedings of the 1974 ACM SIGFIDET Workshop on Data Description, Access and Control | pages = 249\u201364 | publisher = Association for Computing Machinery | year = 1974 | format = PDF | url = http://www.almaden.ibm.com/cs/people/chamberlin/sequel-1974.pdf | accessdate = 2007-06-09 }}</ref>\n<ref name=\"oppel-databases\">{{ cite book | last = Oppel | first = Andy | title = Databases Demystified | publisher = McGraw-Hill Osborne Media | date = February 27, 2004 | location = [[San Francisco, CA]] | pages = 90\u20131 | url = http://www.mhprofessional.com/product.php?cat=112&isbn=0071469605 | isbn = 0-07-146960-5 }}</ref>\n<ref name=\"IBM-history\">{{ cite web | title = History of IBM, 1978 | work = IBM Archives | publisher = IBM | url = http://www-03.ibm.com/ibm/history/history/year_1978.html | accessdate = 2007-06-09 }}</ref>\n<ref name=\"ANSI/ISO/IEC\">ANSI/ISO/IEC International Standard (IS). Database Language SQL\u2014Part 2: Foundation (SQL/Foundation). 1999.</ref>\n<ref name=\"DECODE\">{{ cite web | url = http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions040.htm | title = DECODE | publisher = Docs.oracle.com | accessdate = 2013-06-14 }}</ref>\n<ref name=\"ms-sql-select-into\">{{ cite book | chapter = Transact-SQL Reference | title = SQL Server Language Reference | series = SQL Server 2005 Books Online | publisher = Microsoft | date = 2007-09-15 | url = http://msdn.microsoft.com/en-us/library/ms188029.aspx | accessdate = 2007-06-17 }}</ref>\n<ref name=\"Inline View/Derived Table\">{{ cite web | title = Derived Tables | publisher = ORACLE | url = https://docs.oracle.com/cd/E12032_01/doc/epm.921/html_ir_studio/frameset.htm?/cd/E12032_01/doc/epm.921/html_ir_studio/ir_studio-07-16.html }}</ref>\n<ref name=\"Klein\">{{Cite book | last1 = Hans-Joachim | first1 = K. | chapter = Null Values in Relational Databases and Sure Information Answers | doi = 10.1007/3-540-36596-6_7 | title = Semantics in Databases. Second International Workshop Dagstuhl Castle, Germany, January 7\u201312, 2001. Revised Papers | series = Lecture Notes in Computer Science | volume = 2582 | pages = 119\u2013138| year = 2003 | isbn = 978-3-540-00957-3 | pmid =  | pmc = | url = http://www.is.informatik.uni-kiel.de/~hjk/sqlni.ps}}</ref>\n<ref name=\"Meyden\">[https://books.google.com/books?id=gF0b85IuqQwC&pg=PA344 Ron van der Meyden, \"Logical approaches to incomplete information: a survey\" in Chomicki, Jan; Saake, Gunter (Eds.) ''Logics for Databases and Information Systems'', Kluwer Academic Publishers ISBN 978-0-7923-8129-7, p. 344]</ref>\n<ref name=\"SQL2003-Part2-Sec87\">{{ cite book | last = ISO/IEC | title = ISO/IEC 9075-2:2003, \"SQL/Foundation\" | publisher = ISO/IEC | nopp = true }}</ref>\n<ref name=\"Negri\">[http://portal.acm.org/citation.cfm?id=63224.68822&coll=GUIDE&dl= M. Negri, G. Pelagatti, L. Sbattella (1989) ''GUIDE Semantics and problems of universal quantification in SQL'']</ref>\n<ref name=\"Fratarcangeli\">[http://portal.acm.org/citation.cfm?id=126482.126484&coll=GUIDE&dl=GUIDE&CFID=5934371&CFTOKEN=55309005 Fratarcangeli, Claudio (1991). ''Technique for universal quantification in SQL''. ACM.org.]</ref>\n<ref name=\"kawash\">[http://www.thefreelibrary.com/Complex+quantification+in+Structured+Query+Language+(SQL):+a+tutorial...-a0119901477 Kawash, Jalal (2004) ''Complex quantification in Structured Query Language (SQL): a tutorial using relational calculus'' - Journal of Computers in Mathematics and Science Teaching ISSN 0731-9258 Volume 23, Issue 2, 2004 AACE Norfolk, Virginia. Thefreelibrary.com]</ref>\n<ref name=\"SQL1992\">{{ cite journal | url = http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt | title = Information Technology: Database Language SQL | publisher = CMU }} (proposed revised text of DIS 9075).</ref>\n<ref name=\"Jones 127\">Arie Jones, Ryan K. Stephens, Ronald R. Plew, Alex Kriegel, Robert F. Garrett (2005), ''SQL Functions Programmer's Reference''. Wiley, 127 pages.</ref>\n<ref name=\"sqlr150\">[http://publib.boulder.ibm.com/infocenter/idshelp/v111/index.jsp?topic=/com.ibm.sqlr.doc/sqlr150.htm ] {{dead link|date=August 2016}}</ref>\n<ref name=\"PostgreSQL server programming\">{{ cite web | last = PostgreSQL contributors | title = PostgreSQL server programming | work = PostgreSQL 9.1 official documentation | publisher = postgresql.org | year = 2011 | url = http://www.postgresql.org/docs/9.1/static/server-programming.html | accessdate = 2012-03-09 }}</ref>\n<ref name=\"PROLE\">[http://lbd.udc.es/jornadas2011/actas/PROLE/PROLE/S5/13_article.pdf Outer Joins in a Deductive Database System]</ref>\n<ref name=\"About PostgreSQL\">{{ cite web | last = PostgreSQL contributors | title = About PostgreSQL | work = PostgreSQL 9.1 official website | publisher = PostgreSQL Global Development Group | year = 2012 | url = http://www.postgresql.org/about/ | quote = PostgreSQL prides itself in standards compliance. Its SQL implementation strongly conforms to the ANSI-SQL:2008 standard | accessdate = March 9, 2012 }}</ref>\n<ref name=\"Ora DATE\">{{ cite book | first1 = Diana | last1 = Lorentz | first2 = Mary Beth | last2 = Roeser | first3 = Sundeep | last3 = Abraham | first4 = Angela | last4 = Amor | first5 = Geeta | last5 = Arora | first6 = Vikas | last6 = Arora | first7 = Lance | last7 = Ashdown | first8 = Hermann | last8 = Baer | first9 = Shrikanth | last9 = Bellamkonda | series = Oracle Database Documentation Library | publisher = Oracle USA, Inc | place = Redwood City, CA | title = Oracle Database SQL Language Reference 11g Release 2 (11.2) | chapter = Basic Elements of Oracle SQL: Data Types | origyear = 1996 | date = October 2010 | accessdate = December 29, 2010 | url = http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/sql_elements001.htm#sthref154 | quote = For each <code>DATE</code> value, Oracle stores the following information: century, year, month, date, hour, minute, and second }}</ref>\n<ref name=\"Ora DATETIME\">{{ cite book | first1 = Diana | last1 = Lorentz | first2 = Mary Beth | last2 = Roeser | first3 = Sundeep | last3 = Abraham | first4 = Angela | last4 = Amor | first5 = Geeta | last5 = Arora | first6 = Vikas | last6 = Arora | first7 = Lance | last7 = Ashdown | first8 = Hermann | last8 = Baer | first9 = Shrikanth | last9 = Bellamkonda | series = Oracle Database Documentation Library | publisher = Oracle USA, Inc | place = Redwood City, CA | title = Oracle Database SQL Language Reference 11g Release 2 (11.2) | chapter = Basic Elements of Oracle SQL: Data Types | origyear = 1996 | date = October 2010 | accessdate = December 29, 2010 | url = http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/sql_elements001.htm#sthref154 | quote = The datetime data types are <code>DATE</code>... }}</ref>\n<ref name=\"Ora TIME\">{{ cite book | first1 = Diana | last1 = Lorentz | first2 = Mary Beth | last2 = Roeser | first3 = Sundeep | last3 = Abraham | first4 = Angela | last4 = Amor | first5 = Geeta | last5 = Arora | first6 = Vikas | last6 = Arora | first7 = Lance | last7 = Ashdown | first8 = Hermann | last8 = Baer | first9 = Shrikanth | last9 = Bellamkonda | series = Oracle Database Documentation Library | publisher = Oracle USA, Inc | place = Redwood City, CA | title = Oracle Database SQL Language Reference 11g Release 2 (11.2) | chapter = Basic Elements of Oracle SQL: Data Types | origyear = 1996 | date = October 2010 | accessdate = December 29, 2010 | url = http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/sql_elements001.htm#i54335 | quote = Do not define columns with the following SQL/DS and DB2 data types, because they have no corresponding Oracle data type:... <code>TIME</code> }}</ref>\n<ref name=\"X3H2\">{{ cite book | url = http://special.lib.umn.edu/findaid/xml/cbi00168.xml | publisher = American National Standards Institute | title = X3H2 Records, 1978\u201395 | chapter = Finding Aid }}</ref>\n<ref name=\"Doll\">{{ cite web | last = Doll | first = Shelley | title = Is SQL a Standard Anymore? | work = TechRepublic's Builder.com | publisher = TechRepublic | date = June 19, 2002 | url = http://articles.techrepublic.com.com/5100-10878_11-1046268.html | accessdate = 2016-04-12 | archiveurl = https://web.archive.org/web/20120705163024/http://www.techrepublic.com/article/is-sql-a-standard-anymore/1046268 | archivedate = 2012-07-05 }}</ref>\n<ref name=\"Gillespie\">{{ cite web | last = Gillespie | first = Patrick | url = http://patorjk.com/blog/2012/01/26/pronouncing-sql-s-q-l-or-sequel/ | work = Pronouncing SQL: S-Q-L or Sequel? | title = Pronouncing SQL: S-Q-L or Sequel? | accessdate = 12 February 2012 }}</ref>\n<ref name=\"Melton\">{{ cite book | title = Understanding the New SQL: A Complete Guide | last = Melton | first = Jim | author2 = Alan R Simon | year = 1993 | publisher = Morgan Kaufmann | isbn = 1-55860-245-3 | page = 536 | chapter = 1.2. What is SQL? | quote = SQL (correctly pronounced \"ess cue ell,\" instead of the somewhat common \"sequel\")... }}</ref>\n<ref name=\"SQLXML2006\">{{ cite book | title = SQL/XML:2006 - Evaluierung der Standardkonformit\u00e4t ausgew\u00e4hlter Datenbanksysteme | last = Wagner | first = Michael | year = 2010 | publisher = Diplomica Verlag | isbn = 3-8366-9609-6 | page = 100 | chapter = | quote = }}</ref>\n<ref name=\"iablog.sybase.com-paulley\">{{ cite journal | date = July 2008 | title = SQL:2008 now an approved ISO international standard | publisher = Sybase | url = http://iablog.sybase.com/paulley/2008/07/sql2008-now-an-approved-iso-international-standard/ }}</ref>\n<ref name=\"ISO/IEC 9075-2:2011\">{{ cite web | url = http://www.iso.org/iso/catalogue_detail.htm?csnumber=53682 | title = ISO/IEC 9075-2:2011: Information technology -- Database languages -- SQL -- Part 2: Foundation (SQL/Foundation) }}</ref>\n<ref name=\"Whitemarsh\">{{ cite journal | url = http://www.wiscorp.com/sql200n.zip | format = Zip | title = SQL:2008 draft | publisher = Whitemarsh Information Systems Corporation }}</ref>\n<ref name=\"ISO/IEC 9075-11:2008\">{{ cite journal | title = ISO/IEC 9075-11:2008: Information and Definition Schemas (SQL/Schemata) | page = 1 | year = 2008 }}</ref>\n}}\n\n== References ==\n\n{{refbegin}}\n* {{ cite journal | url = http://www.acm.org/classics/nov95/toc.html | title = A Relational Model of Data for Large Shared Data Banks | first = Edgar F | last = Codd | journal = Communications of the ACM | volume = 13 | date = June 1970 | pages = 377\u201387 | issue = 6 | doi = 10.1145/362384.362685 }}\n* [[c2:SqlFlaws|Discussion on alleged SQL flaws]] (C2 wiki)\n* [[C. J. Date]] with [[Hugh Darwen]]: ''A Guide to the SQL standard : a users guide to the standard database language SQL, 4th ed.'', Addison Wesley, USA 1997, ISBN 978-0-201-96426-4\n{{refend}}\n\n== External links ==\n{{Sister project links\n|commons=Category:Structured Query Language\n|v=Introduction to SQL\n|b=Structured Query Language\n|n=no|s=no|q=no}}\n* [http://www.mcjones.org/System_R/SQL_Reunion_95/sqlr95.html ''1995 SQL Reunion: People, Projects, and Politics'', by Paul McJones (ed.)]: transcript of a reunion meeting devoted to the personal history of relational databases and SQL.\n* [http://special.lib.umn.edu/findaid/xml/cbi00168.xml American National Standards Institute. X3H2 Records, 1978\u20131995] [[Charles Babbage Institute]] Collection documents the H2 committee's development of the NDL and SQL standards.\n* [http://purl.umn.edu/107215 Oral history interview with Donald D. Chamberlin] [[Charles Babbage Institute]] In this oral history Chamberlin recounts his early life, his education at [[Harvey Mudd College]] and [[Stanford University]], and his work on relational database technology. Chamberlin was a member of the System R research team and, with [[Raymond F. Boyce]], developed the SQL database language. Chamberlin also briefly discusses his more recent research on XML query languages.\n* [http://troels.arvin.dk/db/rdbms/ Comparison of Different SQL Implementations] This comparison of various SQL implementations is intended to serve as a guide to those interested in porting SQL code between various RDBMS products, and includes comparisons between SQL:2008, PostgreSQL, DB2, MS SQL Server, MySQL, Oracle, and Informix.\n*[http://www.sqlstream.com/stream-processing-with-sql/ Event stream processing with SQL] - An introduction to real-time processing of streaming data with continuous SQL queries\n\n{{SQL}}\n{{Databases}}\n{{Query languages}}\n{{IBM}}\n{{ISO standards}}\n\n{{Authority control}}\n\n[[Category:Articles with example SQL code]]\n[[Category:Data modeling languages]]\n[[Category:Declarative programming languages]]\n[[Category:Query languages]]\n[[Category:Relational database management systems]]\n[[Category:SQL| ]]\n[[Category:Programming languages with an ISO standard]]"}]}}}}